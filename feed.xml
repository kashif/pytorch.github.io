<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator>
  <link href="https://pytorch.org/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://pytorch.org/" rel="alternate" type="text/html" />
  <updated>2024-07-10T19:48:43-07:00</updated>
  <id>https://pytorch.org/feed.xml</id>

  
  
  

  
    <title type="html">PyTorch Website</title>
  

  
    <subtitle>Scientific Computing...</subtitle>
  

  
    <author>
        <name>Facebook</name>
      
      
    </author>
  

  
  
  
    <entry>
      <title type="html">Learn how to develop Android applications with ExecuTorch and Llama models</title>
      <link href="https://pytorch.org/blog/develop-android-applications/" rel="alternate" type="text/html" title="Learn how to develop Android applications with ExecuTorch and Llama models" />
      <published>2024-07-10T00:00:00-07:00</published>
      <updated>2024-07-10T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/develop-android-applications</id>
      <content type="html" xml:base="https://pytorch.org/blog/develop-android-applications/">&lt;p&gt;&lt;em&gt;This blog is courtesy of the PyTorch team at Arm. More details can be found &lt;a href=&quot;https://learn.arm.com/learning-paths/smartphones-and-mobile/build-llama3-chat-android-app-using-executorch-and-xnnpack/?utm_source=twitter&amp;amp;utm_medium=social-organic&amp;amp;utm_content=landingpage&amp;amp;utm_campaign=mk24_developer_na&quot;&gt;here&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Arm’s compute platform is delivering GenAI applications on phones, laptops, and servers. Cost, privacy, performance, security, and energy efficiency are just some of the reasons developers are investigating on-device AI.&lt;/p&gt;

&lt;p&gt;A new Learning Path explaining how to leverage the capabilities of large language models (LLMs) on Android using ExecuTorch and XNNPACK is now available.&lt;/p&gt;

&lt;p&gt;Here’s a summary of what you’ll learn:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Development Environment setup&lt;/p&gt;

    &lt;p&gt;The Learning Path begins by guiding you through setting up your development environment, ensuring you have all the necessary tools installed, including Android Studio, the Android NDK, Java JDK, and Python.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ExecuTorch and XNNPACK&lt;/p&gt;

    &lt;p&gt;You’ll learn about the core technologies: ExecuTorch, a framework for deploying PyTorch models to edge devices, and XNNPACK, a high-performance library for executing neural networks on Arm-based platforms.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Llama models&lt;/p&gt;

    &lt;p&gt;The Learning Path explores Llama, a family of powerful LLMs, focusing specifically on the 8B Llama 3 model. You’ll learn about quantization techniques, which are essential for optimizing model size and performance on mobile devices.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Prepare Llama models for ExecuTorch&lt;/p&gt;

    &lt;p&gt;You’ll be guided through the process of downloading, exporting, and evaluating Llama models, ensuring they are ready for deployment using ExecuTorch.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Check model performance on Android&lt;/p&gt;

    &lt;p&gt;The Learning Path walks you through cross-compiling the Llama runner binary for Android, allowing you to test your model’s performance on your phone.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Build and run an Android Chat App&lt;/p&gt;

    &lt;p&gt;Finally, you’ll learn how to build a native Android chat app using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LlamaDemo&lt;/code&gt; application from the ExecuTorch repository. This hands-on experience allows you to put your knowledge into practice and create a real-world application.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Explore this Learning Path if you want to learn how to leverage the power of LLMs on your Android phone, and gain expertise in tools for on-device machine learning.&lt;/p&gt;

&lt;p&gt;Dig into the excitement of building Android chat apps and understand more about how they work on the &lt;a href=&quot;https://learn.arm.com/learning-paths/smartphones-and-mobile/build-llama3-chat-android-app-using-executorch-and-xnnpack/?utm_source=twitter&amp;amp;utm_medium=social-organic&amp;amp;utm_content=landingpage&amp;amp;utm_campaign=mk24_developer_na&quot;&gt;Arm Developer Hub&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Arm</name>
        
        
      </author>

      

      

      
        <summary type="html">This blog is courtesy of the PyTorch team at Arm. More details can be found here.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Accelerated PyTorch inference with torch.compile on AWS Graviton processors</title>
      <link href="https://pytorch.org/blog/accelerated-pytorch-inference/" rel="alternate" type="text/html" title="Accelerated PyTorch inference with torch.compile on AWS Graviton processors" />
      <published>2024-07-09T00:00:00-07:00</published>
      <updated>2024-07-09T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/accelerated-pytorch-inference</id>
      <content type="html" xml:base="https://pytorch.org/blog/accelerated-pytorch-inference/">&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;Originally PyTorch, used an eager mode where each PyTorch operation that forms the model is run independently as soon as it’s reached. PyTorch 2.0 introduced &lt;a href=&quot;https://pytorch.org/tutorials/intermediate/torch_compile_tutorial.html&quot;&gt;torch.compile&lt;/a&gt; to speed up PyTorch code over the default eager mode. In contrast to eager mode, the torch.compile pre-compiles the entire model into a single graph in a manner that’s optimal for running on a given hardware platform. AWS optimized the PyTorch torch.compile feature for &lt;a href=&quot;https://aws.amazon.com/about-aws/whats-new/2022/05/amazon-ec2-c7g-instances-powered-aws-graviton3-processors/&quot;&gt;AWS Graviton3 processors&lt;/a&gt;. This optimization results in up to 2x better performance for &lt;a href=&quot;https://huggingface.co/models&quot;&gt;Hugging Face&lt;/a&gt; model inference (based on geomean of performance improvement for 33 models) and up to 1.35x better performance for &lt;a href=&quot;https://github.com/pytorch/benchmark&quot;&gt;TorchBench&lt;/a&gt; model inference (geomean of performance improvement for 45 models) compared to the default eager mode inference across several natural language processing (NLP), computer vision (CV), and recommendation models on AWS Graviton3-based Amazon EC2 instances. Starting with PyTorch 2.3.1, the optimizations are available in torch Python &lt;a href=&quot;https://pypi.org/project/torch/2.3.1/&quot;&gt;wheels&lt;/a&gt; and AWS Graviton PyTorch &lt;a href=&quot;https://github.com/aws/deep-learning-containers/blob/master/available_images.md#ec2-framework-graviton-containers-ec2-ecs-and-eks-support-only&quot;&gt;deep learning container (DLC)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this blog post, we show how we optimized torch.compile performance on AWS Graviton3-based EC2 instances, how to use the optimizations to improve inference performance, and the resulting speedups.&lt;/p&gt;

&lt;h2 id=&quot;why-torchcompile-and-whats-the-goal&quot;&gt;Why torch.compile and what’s the goal?&lt;/h2&gt;

&lt;p&gt;In eager mode, operators in a model are run immediately as they are encountered. It’s easier to use, more suitable for machine learning (ML) researchers, and hence is the default mode. However, eager mode incurs runtime overhead because of redundant kernel launch and memory read overhead. Whereas in torch compile mode, operators are first synthesized into a graph, wherein one operator is merged with another to reduce and localize memory reads and total kernel launch overhead.&lt;/p&gt;

&lt;p&gt;The goal for the AWS Graviton team was to optimize torch.compile backend for Graviton3 processors. PyTorch eager mode was already optimized for Graviton3 processors with &lt;a href=&quot;https://github.com/ARM-software/ComputeLibrary&quot;&gt;Arm Compute Library (ACL)&lt;/a&gt; kernels using oneDNN (also known as MKLDNN). So, the question was, how to reuse those kernels in torch.compile mode to get the best of graph compilation and the optimized kernel performance together?&lt;/p&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;

&lt;p&gt;The AWS Graviton team extended the torch inductor and oneDNN primitives that reused the ACL kernels and optimized compile mode performance on Graviton3 processors. Starting with PyTorch 2.3.1, the optimizations are available in the torch Python wheels and AWS Graviton DLC. Please see the &lt;strong&gt;Running an inference&lt;/strong&gt; section that follows for the instructions on installation, runtime configuration, and how to run the tests.&lt;/p&gt;

&lt;p&gt;To demonstrate the performance improvements, we used NLP, CV, and recommendation models from &lt;a href=&quot;https://github.com/pytorch/benchmark&quot;&gt;TorchBench&lt;/a&gt; and the most downloaded NLP models from &lt;a href=&quot;https://huggingface.co/models&quot;&gt;Hugging Face&lt;/a&gt; across Question Answering, Text Classification, Token Classification, Translation, Zero-Shot Classification, Translation, Summarization, Feature Extraction, Text Generation, Text2Text Generation, Fill-Mask, and Sentence Similarity tasks to cover a wide variety of customer use cases.&lt;/p&gt;

&lt;p&gt;We started with measuring TorchBench model inference latency, in milliseconds (msec), for the eager mode, which is marked 1.0 with a red dotted line in the following graph. Then we compared the improvements from torch.compile for the same model inference, the normalized results are plotted in the graph. You can see that for the 45 models we benchmarked, there is a 1.35x latency improvement (geomean for the 45 models).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerated-pytorch-inference/fg1.png&quot; alt=&quot;PyTorch model inference performance improvement with torch.compile on AWS Graviton3-based c7g instance using TorchBench framework&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Image 1&lt;/strong&gt;: PyTorch model inference performance improvement with torch.compile on AWS Graviton3-based c7g instance using TorchBench framework. The reference eager mode performance is marked as 1.0. (higher is better)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Similar to the preceding TorchBench inference performance graph, we started with measuring the Hugging Face NLP model inference latency, in msec, for the eager mode, which is marked 1.0 with a red dotted line in the following graph. Then we compared the improvements from torch.compile for the same model inference, the normalized results are plotted in the graph. You can see that for the 33 models we benchmarked, there is around 2x performance improvement (geomean for the 33 models).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerated-pytorch-inference/fg2.png&quot; alt=&quot;Hugging Face NLP model inference performance improvement with torch.compile on AWS Graviton3-based c7g instance using Hugging Face example scripts&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Image 2&lt;/strong&gt;: Hugging Face NLP model inference performance improvement with torch.compile on AWS Graviton3-based c7g instance using Hugging Face example scripts. The reference eager mode performance is marked as 1.0. (higher is better)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;running-an-inference&quot;&gt;Running an inference&lt;/h2&gt;

&lt;p&gt;Starting with PyTorch 2.3.1, the optimizations are available in the torch Python wheel and in AWS Graviton PyTorch DLC. This section shows how to run inference in eager and torch.compile modes using torch Python wheels and benchmarking scripts from Hugging Face and TorchBench repos.&lt;/p&gt;

&lt;p&gt;To successfully run the scripts and reproduce the speedup numbers mentioned in this post, you need an instance from the Graviton3 family (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c7g/r7g/m7g/hpc7g&lt;/code&gt;) of hardware. For this post, we used the &lt;a href=&quot;https://aws.amazon.com/ec2/instance-types/c7g/&quot;&gt;c7g.4xl (16 vcpu) instance&lt;/a&gt;. The instance, the AMI details, and the required torch library versions are mentioned in the following snippet.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Instance: c7g.4xl instance
Region: us-west-2
AMI: ami-05cc25bfa725a144a﻿ (Ubuntu 22.04/Jammy with 6.5.0-1017-aws kernel)

# Install Python
sudo apt-get update
sudo apt-get install -y python3 python3-pip

# Upgrade pip3 to the latest version
python3 -m pip install --upgrade pip

# Install PyTorch and extensions
python3 -m pip install torch==2.3.1 torchvision==0.18.1 torchaudio==2.3.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The generic runtime tunings implemented for eager mode inference are equally applicable for the torch.compile mode, so, we set the following environment variables to further improve the torch.compile performance on AWS Graviton3 processors.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Enable the fast math GEMM kernels, to accelerate fp32 inference with bfloat16 gemm
export DNNL_DEFAULT_FPMATH_MODE=BF16

# Enable Linux Transparent Huge Page (THP) allocations,
# to reduce the tensor memory allocation latency
export THP_MEM_ALLOC_ENABLE=1

# Set LRU Cache capacity to cache the primitives and avoid redundant
# memory allocations
export LRU_CACHE_CAPACITY=1024
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;torchbench-benchmarking-scripts&quot;&gt;TORCHBENCH BENCHMARKING SCRIPTS&lt;/h4&gt;

&lt;p&gt;TorchBench is a collection of open source benchmarks used to evaluate PyTorch performance. We benchmarked 45 models using the scripts from the TorchBench repo. Following code shows how to run the scripts for the eager mode and the compile mode with inductor backend.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Set OMP_NUM_THREADS to number of vcpus, 16 for c7g.4xl instance
export OMP_NUM_THREADS=16

# Install the dependencies
sudo apt-get install -y libgl1-mesa-glx
sudo apt-get install -y libpangocairo-1.0-0
python3 -m pip install psutil numpy transformers pynvml numba onnx onnxruntime scikit-learn timm effdet gym doctr opencv-python h5py==3.10.0 python-doctr 

# Clone pytorch benchmark repo
git clone https://github.com/pytorch/benchmark.git
cd benchmark
# PyTorch benchmark repo doesn't have any release tags. So,
# listing the commit we used for collecting the performance numbers
git checkout 9a5e4137299741e1b6fb7aa7f5a6a853e5dd2295

# Setup the models
python3 install.py 

# Colect eager mode performance using the following command. The results will be
# stored at .userbenchmark/cpu/metric-&amp;lt;timestamp&amp;gt;.json.
python3 run_benchmark.py cpu --model BERT_pytorch,hf_Bert,hf_Bert_large,hf_GPT2,hf_Albert,hf_Bart,hf_BigBird,hf_DistilBert,hf_GPT2_large,dlrm,hf_T5,mnasnet1_0,mobilenet_v2,mobilenet_v3_large,squeezenet1_1,timm_efficientnet,shufflenet_v2_x1_0,timm_regnet,resnet50,soft_actor_critic,phlippe_densenet,resnet152,resnet18,resnext50_32x4d,densenet121,phlippe_resnet,doctr_det_predictor,timm_vovnet,alexnet,doctr_reco_predictor,vgg16,dcgan,yolov3,pytorch_stargan,hf_Longformer,timm_nfnet,timm_vision_transformer,timm_vision_transformer_large,nvidia_deeprecommender,demucs,tts_angular,hf_Reformer,pytorch_CycleGAN_and_pix2pix,functorch_dp_cifar10,pytorch_unet --test eval --metrics=&quot;latencies,cpu_peak_mem&quot;

# Collect torch.compile mode performance with inductor backend
# and weights pre-packing enabled. The results will be stored at
# .userbenchmark/cpu/metric-&amp;lt;timestamp&amp;gt;.json
python3 run_benchmark.py cpu --model BERT_pytorch,hf_Bert,hf_Bert_large,hf_GPT2,hf_Albert,hf_Bart,hf_BigBird,hf_DistilBert,hf_GPT2_large,dlrm,hf_T5,mnasnet1_0,mobilenet_v2,mobilenet_v3_large,squeezenet1_1,timm_efficientnet,shufflenet_v2_x1_0,timm_regnet,resnet50,soft_actor_critic,phlippe_densenet,resnet152,resnet18,resnext50_32x4d,densenet121,phlippe_resnet,doctr_det_predictor,timm_vovnet,alexnet,doctr_reco_predictor,vgg16,dcgan,yolov3,pytorch_stargan,hf_Longformer,timm_nfnet,timm_vision_transformer,timm_vision_transformer_large,nvidia_deeprecommender,demucs,tts_angular,hf_Reformer,pytorch_CycleGAN_and_pix2pix,functorch_dp_cifar10,pytorch_unet --test eval --torchdynamo inductor --freeze_prepack_weights --metrics=&quot;latencies,cpu_peak_mem&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;On successful completion of the inference runs, the script stores the results in JSON format. The following is the sample output:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
 &quot;name&quot;: &quot;cpu&quot;
 &quot;environ&quot;: {
     &quot;pytorch_git_version&quot;: &quot;d44533f9d073df13895333e70b66f81c513c1889&quot;
  },
  
  &quot;metrics&quot;: {
       &quot;BERT_pytorch-eval_latency&quot;: 56.3769865,
       &quot;BERT_pytorch-eval_cmem&quot;: 0.4169921875
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;hugging-face-benchmarking-scripts&quot;&gt;HUGGING FACE BENCHMARKING SCRIPTS&lt;/h4&gt;

&lt;p&gt;Google T5 Small Text Translation model is one of the around 30 Hugging Face models we benchmarked. We’re using it as a sample model to demonstrate how to run inference in eager and compile modes. The additional configurations and APIs required to run it in compile mode are highlighted in &lt;strong&gt;BOLD&lt;/strong&gt;. Save the following script as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;google_t5_small_text_translation.py&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import argparse
from transformers import T5Tokenizer, T5Model
import torch
from torch.profiler import profile, record_function, ProfilerActivity
&lt;b&gt;import torch._inductor.config as config
config.cpp.weight_prepack=True
config.freezing=True&lt;/b&gt;

def test_inference(mode, num_iter):
    tokenizer = T5Tokenizer.from_pretrained(&quot;t5-small&quot;)
    model = T5Model.from_pretrained(&quot;t5-small&quot;)

    input_ids = tokenizer(
        &quot;Studies have been shown that owning a dog is good for you&quot;, return_tensors=&quot;pt&quot;
    ).input_ids  # Batch size 1
    decoder_input_ids = tokenizer(&quot;Studies show that&quot;, return_tensors=&quot;pt&quot;).input_ids  # Batch size 1

    &lt;b&gt;if (mode == 'compile'):
        model = torch.compile(model)&lt;/b&gt;

    with torch.no_grad():
        for _ in range(50):
            outputs = model(input_ids=input_ids, decoder_input_ids=decoder_input_ids)

        with profile(activities=[ProfilerActivity.CPU]) as prof:
            with record_function(&quot;model_inference&quot;):
                for _ in range(num_iter):
                    outputs = model(input_ids=input_ids, decoder_input_ids=decoder_input_ids)

    print(prof.key_averages().table(sort_by=&quot;self_cpu_time_total&quot;))

def main() -&amp;gt; None:
    global m, args
    parser = argparse.ArgumentParser(__doc__)
    parser.add_argument(
        &quot;-m&quot;,
        &quot;--mode&quot;,
        choices=[&quot;eager&quot;, &quot;compile&quot;],
        default=&quot;eager&quot;,
        help=&quot;Which test to run.&quot;,
    )
    parser.add_argument(
        &quot;-n&quot;,
        &quot;--number&quot;,
        type=int,
        default=100,
        help=&quot;how many iterations to run.&quot;,
    )
    args = parser.parse_args()
    test_inference(args.mode, args.number)

if __name__ == &quot;__main__&quot;:
    main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run the script with the following steps:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Set OMP_NUM_THREADS to number of vcpus to 4 because
# the scripts are running inference in sequence, and
# they don't need large number of vcpus
export OMP_NUM_THREADS=4

# Install the dependencies
python3 -m pip install transformers

# Run the inference script in Eager mode
# using number of iterations as 1 just to show the torch profiler output
# but for the benchmarking, we used 1000 iterations.
python3 google_t5_small_text_translation.py -n 1 -m eager

# Run the inference script in torch compile mode
python3 google_t5_small_text_translation.py -n 1 -m compile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;On successful completion of the inference runs, the script prints the torch profiler output with the latency breakdown for the torch operators. The following is the sample output from torch profiler:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Torch profiler output for the eager mode run on c7g.xl (4vcpu)
------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                    Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                aten::mm        40.71%      12.502ms        40.71%      12.502ms     130.229us            96  
         model_inference        26.44%       8.118ms       100.00%      30.708ms      30.708ms             1  
               aten::bmm         6.85%       2.102ms         9.47%       2.908ms      80.778us            36  
            aten::matmul         3.73%       1.146ms        57.26%      17.583ms     133.205us           132  
            aten::select         1.88%     576.000us         1.90%     583.000us       0.998us           584  
         aten::transpose         1.51%     464.000us         1.83%     563.000us       3.027us           186  
------------------------ ------------ ------------ ------------ ------------ ------------ -------------------
Self CPU time total: 30.708ms

# Torch profiler output for the compile mode run for the same model on the same instance
---------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                             Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
---------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
        mkldnn::_linear_pointwise        37.98%       5.461ms        45.91%       6.602ms      68.771us            96  
            Torch-Compiled Region        29.56%       4.251ms        98.53%      14.168ms      14.168ms             1  
                        aten::bmm        14.90%       2.143ms        21.73%       3.124ms      86.778us            36  
                     aten::select         4.51%     648.000us         4.62%     665.000us       1.155us           576  
                       aten::view         3.29%     473.000us         3.29%     473.000us       1.642us           288  
                      aten::empty         2.53%     364.000us         2.53%     364.000us       3.165us           115  
--------------------------------- ------------ ------------ ------------ ------------ ------------ --------------------
Self CPU time total: 14.379ms
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;technical-deep-dive-what-are-the-challenges-and-optimization-details&quot;&gt;Technical deep dive: What are the challenges and optimization details&lt;/h2&gt;

&lt;p&gt;Underpinning torch.compile are new technologies – TorchDynamo, AOTDispatcher, and TorchInductor.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TorchDynamo&lt;/strong&gt; captures PyTorch programs safely using Python Frame Evaluation Hooks&lt;br /&gt;
&lt;strong&gt;AOTDispatcher&lt;/strong&gt; overloads PyTorch’s autograd engine as a tracing autodiff for generating ahead-of-time backward traces.&lt;br /&gt;
&lt;strong&gt;TorchInductor&lt;/strong&gt; is a deep learning compiler that generates fast code for multiple accelerators and backends.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerated-pytorch-inference/fg3.png&quot; alt=&quot;The PyTorch compilation process source&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Image 3&lt;/strong&gt;: The PyTorch compilation process&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;When torch.compile is invoked, torch dynamo rewrites Python bytecode to extract sequences of PyTorch operations into an &lt;a href=&quot;https://pytorch.org/docs/stable/fx.html&quot;&gt;FX&lt;/a&gt; &lt;a href=&quot;https://pytorch.org/docs/stable/fx.html&quot;&gt;Graph&lt;/a&gt;, which is then compiled with inductor backend. For a typical inference scenario where the graph is frozen and gradient calculations are disabled, the inductor invokes platform specific optimizations like graph rewrite into more performant operators, operator fusion, and weights pre-packing.&lt;/p&gt;

&lt;p&gt;However, on Graviton3, the inductor wasn’t able to perform any of those optimizations because there was no aarch64 backend defined. To fix this, we extended the inductor’s FX passes to pick oneDNN operators for linear layer compilation on Graviton3 processors with ACL backend. The code snippet for this follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;packed_weight_op = (
    mkldnn._reorder_linear_weight
    if (is_bf16_weight or mkldnn._is_mkldnn_acl_supported())
                    
packed_linear_inputs: Tuple[Any, ...] = (input, packed_weight_node)
if is_bf16_weight or mkldnn._is_mkldnn_acl_supported():
    packed_linear_inputs += (bias, &quot;none&quot;, [], &quot;&quot;)
    packed_linear_op = mkldnn._linear_pointwise.default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After this was done, the FX pass was successful in compiling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;matmul &lt;/code&gt;operators to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;linear_pointwise &lt;/code&gt;. The following snippet highlights the matmul operator in the original model:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; %attention_scores   : [num_users=1] = call_function[target=torch.matmul](args = (%query_layer, %transpose), kwargs = {})
 %attention_scores_1 : [num_users=1] = call_function[target=operator.truediv](args = (%attention_scores, 8.0), kwargs = {})
 %attention_scores_2 : [num_users=1] = call_function[target=operator.add](args = (%attention_scores_1, %extended_attention_mask_3), kwargs = {})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The following snippet highlights the linear_pointwise operator in the compiled graph:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%_linear_pointwise_default_140 : [num_users=2] = call_function[target=torch.ops.mkldnn._linear_pointwise.default](args = (%add_7, %_frozen_param278, %_frozen_param16, none, [], ), kwargs = {})
%mul_5 : [num_users=1] = call_function[target=torch.ops.aten.mul.Tensor](args = (%_linear_pointwise_default_140, 0.5), kwargs = {})
%mul_6 : [num_users=1] = call_function[target=torch.ops.aten.mul.Tensor](args = (%_linear_pointwise_default_140, 0.7071067811865476), kwargs = {})
%erf   : [num_users=1] = call_function[target=torch.ops.aten.erf.default](args = (%mul_6,), kwargs = {})
%add_8 : [num_users=1] = call_function[target=torch.ops.aten.add.Tensor](args = (%erf, 1), kwargs = {})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This completes the torch inductor changes required to compile the graph into optimized operators on AWS Graviton3 processors. Next comes the actual inference where the compiled graph is dispatched to be run. OneDNN with ACL was the backend we chose during the inductor compilation, so, the new operators were dispatched to oneDNN as expected, for example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkldnn._linear_pointwise&lt;/code&gt;. However, due to gaps in oneDNN ACL primitives, the operators were run with C++ reference kernels instead of the optimized ACL kernels. Hence, the compile performance was still significantly behind the eager mode performance.&lt;/p&gt;

&lt;p&gt;There were mainly three areas where oneDNN ACL primitives lack support for torch.compile mode. The following section talks about them in detail.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. ACL primitives didn’t have support for weights in blocked layout&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ACL primitives originally designed for eager mode supported weights only in the standard channels last (&lt;a href=&quot;https://oneapi-src.github.io/oneDNN/dev_guide_understanding_memory_formats.html#nhwc&quot;&gt;NHWC&lt;/a&gt;) format, without any pre-packing. Whereas weights pre-packing into blocked layout is one of the main optimizations in the inductor compilation passes where the weights are reordered into blocks specific to the runtime platform. This avoids the redundant and on-the-fly reorders when running the General Matrix Multiplication (GEMM), which otherwise would be the bottleneck for inference performance. But the ACL primitives didn’t have support for blocked layout and hence the operators were run with oneDNN C++ reference kernels instead.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Mixed precision primitives weren’t supported in oneDNN&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AWS Graviton3 processors support &lt;a href=&quot;https://developer.arm.com/documentation/ddi0596/2020-12/SVE-Instructions/BFMMLA--BFloat16-floating-point-matrix-multiply-accumulate-&quot;&gt;bfloat16 MMLA instructions&lt;/a&gt; which can be used to accelerate fp32 inference with bfloat16 GEMM as a mixed precision compute. ACL supports bfloat16 mixed precision GEMM kernels, and are integrated into oneDNN as a fast math compute option for the existing fp32 operators. However, the fast math approach didn’t work for compile mode because of weights pre-packing optimization. The compile mode requires explicit mixed precision primitive implementation in oneDNN in order to use bfloat16 acceleration.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. ACL primitives didn’t support fused kernels for some of the activation functions&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In eager mode, operators are dispatched individually because the model is run independently as soon as it’s reached. Whereas in compile mode, operator fusion is another important optimization where the operators are fused for runtime efficiency. For example, Gaussian Error Linear Unit (&lt;a href=&quot;https://arxiv.org/pdf/1606.08415.pdf#%3A~%3Atext%3DWe%20propose%20the%20Gaussian%20Error%2Cstandard%20Gaussian%20cumulative%20distribution%20function&quot;&gt;GELU&lt;/a&gt;) is one of the most widely used activation functions in transformers-based neural network architectures. So, it’s typical to have a linear layer (with matrix multiplications) followed by GELU activation. As part of compiling the model into efficient operators, the torch inductor fuses matmul and GELU into a single linearpointwise+gelu operator. However, oneDNN ACL primitives didn’t have the support for fused kernels with GELU.&lt;/p&gt;

&lt;p&gt;We addressed these gaps by extending oneDNN primitives to handle the additional layouts and new primitive definitions. The following sections talk about the optimizations in detail.&lt;/p&gt;

&lt;h3 id=&quot;optimization-1-extended-acl-primitives-to-accept-weight-tensors-in-blocked-layout&quot;&gt;Optimization 1: Extended ACL primitives to accept weight tensors in blocked layout&lt;/h3&gt;

&lt;p&gt;We extended the ACL primitives to accept blocked layout in addition to the the standard NHWC format. The code snippet for this is as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const bool is_weights_md_format_ok
                    = utils::one_of(weights_format_kind_received,
                      format_kind::any, format_kind::blocked);


const memory_desc_t weights_md_received = weights_md_;
acl_utils::reorder_to_weight_format(aip.wei_tensor_info,
             weights_md_, expected_weight_format, inner_dim, o_dim,
             remaining_dims, {});

ACL_CHECK_SUPPORT(
     (weights_format_kind_received == format_kind::blocked)
      &amp;amp;&amp;amp; !(dnnl_memory_desc_equal(
      &amp;amp;weights_md_received, &amp;amp;weights_md_)),
      &quot;specified blocked format not supported by ACL, use &quot;
      &quot;format_kind_t::any to find a supported blocked format for &quot;
      &quot;your platform&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;optimization-2-defined-new-acl-primitives-to-handle-mixed-precision-operators-weights-in-bfloat16-and-activations-in-fp32&quot;&gt;Optimization 2: Defined new ACL primitives to handle mixed precision operators (weights in bfloat16 and activations in fp32)&lt;/h3&gt;

&lt;p&gt;We defined mixed precision primitive definitions and updated the existing oneDNN ACL fp32 primitives to handle bfloat16 tensors.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /* With graph compilation, we are able to reorder and pre-pack the weights during the model load
  * and compilation phase itself so that redundant and on-the-fly reorders can be avoided.
  * This primitive definition is to support gemm fastmath mode for the compile scenario where src is
  * in fp32 and weights are in bf16
  */
 {{forward, f32, bf16, f32}, {
    CPU_INSTANCE_AARCH64_ACL(acl_inner_product_fwd_t)
    nullptr,
 }},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;optimization-3-disabled-operator-fusion-pass-in-torch-inductor&quot;&gt;Optimization 3: Disabled operator fusion pass in torch inductor&lt;/h3&gt;

&lt;p&gt;We bypassed the operator fusion pass in torch inductor so that the compiled graph doesn’t contain GELU fused operators. This is a temporary solution to enable ACL kernels in torch.compile. There is a work in progress to enable operator fusion pass for the future PyTorch releases. With this workaround, we were able to successfully dispatch the linear layer to ACL. As shown in the following torch.profiler output, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aten::addmm &lt;/code&gt;(one of the variants of the matmul operator) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aten::gelu &lt;/code&gt;in the original model (as highlighted in &lt;em&gt;Image 4&lt;/em&gt;) was compiled to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mkldnn::_linear_pointwise &lt;/code&gt;without &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gelu &lt;/code&gt;operator fusion (as highlighted in &lt;em&gt;Image 5&lt;/em&gt;).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;---------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                       Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
---------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                aten::addmm        73.32%      46.543ms        74.49%      47.287ms     647.767us            73  
            model_inference         9.92%       6.296ms       100.00%      63.479ms      63.479ms             1  
                  aten::bmm         4.37%       2.776ms         5.46%       3.467ms     144.458us            24  
                aten::copy_         1.74%       1.102ms         1.74%       1.102ms       8.103us           136  
                 aten::gelu         1.50%     950.000us         1.50%     950.000us      79.167us            12  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Image 4&lt;/strong&gt;: torch.profiler output for Hugging Face bert base model inference in Eager mode, showing addmm and gelu operators&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;mt-3 mb-3&quot;&gt;&amp;nbsp;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-----------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                                                 Name    Self CPU %      Self CPU   CPU total %     CPU total  CPU time avg    # of Calls  
-----------------------------------------------------  ------------  ------------  ------------  ------------  ------------  ------------  
                            mkldnn::_linear_pointwise        53.61%      15.529ms        57.53%      16.665ms     228.288us            73  
                                Torch-Compiled Region        36.95%      10.705ms        99.31%      28.769ms      28.769ms             1  
    aten::_scaled_dot_product_flash_attention_for_cpu         3.67%       1.064ms         4.43%       1.284ms     107.000us            12  
                                           aten::view         1.97%     572.000us         1.97%     572.000us       2.509us           228  
                                          aten::empty         1.38%     399.000us         1.38%     399.000us       3.270us           122 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Image 5&lt;/strong&gt;: torch.profiler output for Hugging Face Bert base model inference in torch.compile mode, showing linear_pointwise operator without gelu fusion&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Lastly, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gelu &lt;/code&gt;operator was compiled into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;erf &lt;/code&gt;(error function) and was dispatched to an inductor auto vectorization backend. The following snippets show the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;erf &lt;/code&gt;operator in the compiled graph and running it using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libm.so&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%_linear_pointwise_default_140 : [num_users=2] = call_function[target=torch.ops.mkldnn._linear_pointwise.default](args = (%add_7, %_frozen_param278, %_frozen_param16, none, [], ), kwargs = {})
%mul_5 : [num_users=1] = call_function[target=torch.ops.aten.mul.Tensor](args = (%_linear_pointwise_default_140, 0.5), kwargs = {})
%mul_6 : [num_users=1] = call_function[target=torch.ops.aten.mul.Tensor](args = (%_linear_pointwise_default_140, 0.7071067811865476), kwargs = {})
%erf   : [num_users=1] = call_function[target=torch.ops.aten.erf.default](args = (%mul_6,), kwargs = {})
%add_8 : [num_users=1] = call_function[target=torch.ops.aten.add.Tensor](args = (%erf, 1), kwargs = {})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Image 6&lt;/strong&gt;: snippet after post grad pass showing erf function in the compiled graph&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;mt-3 mb-3&quot;&gt;&amp;nbsp;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     0.82%     0.40%  python3  libm.so.6            [.] erff32
     0.05%     0.00%  python3  libtorch_python.so   [.] torch::autograd::THPVariable_erf
     0.05%     0.00%  python3  libtorch_cpu.so      [.] at::_ops::erf::call
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Image 7&lt;/strong&gt;: Linux perf report showing erf dispatch to libm.so&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With this work, we were able to optimize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile &lt;/code&gt;performance on Graviton3 processors by using inductor graph compilation along with the oneDNN+ACL backend.&lt;/p&gt;

&lt;h3 id=&quot;torchbench-enhancements&quot;&gt;TorchBench enhancements&lt;/h3&gt;

&lt;p&gt;To demonstrate the torch.compile performance improvements on AWS Graviton3 processors, we extended TorchBench framework to add a new argument to enable graph freeze and weights pre-packing and disable torch auto grad for eval test mode. The code snippet for this is as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;parser.add_argument(
 &quot;—freeze_prepack_weights&quot;,
 action='store_true',
 help=&quot;set to freeze the graph and prepack weights&quot;,
 )

if args.freeze_prepack_weights:
 torch._inductor.config.freezing=True
 torch._inductor.config.cpp.weight_prepack=True
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;Image 8&lt;/strong&gt;: Added freeze_prepack_weights option for torchdynamo backend in TorchBench to demonstrate torch.compile performance improvements on AWS Graviton3 processors&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We have upstreamed all the optimizations, and starting with PyTorch 2.3.1, these are supported in torch Python wheels and AWS Graviton PyTorch DLC.&lt;/p&gt;

&lt;h2 id=&quot;whats-next&quot;&gt;What’s next&lt;/h2&gt;

&lt;p&gt;Next, we’re extending the torch inductor CPU backend support to compile Llama model, and adding support for fused GEMM kernels to enable torch inductor operator fusion optimization on AWS Graviton3 processors.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;In this tutorial, we covered how we optimized torch.compile performance on AWS Graviton3-based EC2 instances, how to use the optimizations to improve PyTorch model inference performance, and demonstrated the resulting speedups. We hope that you will give it a try! If you need any support with ML software on Graviton, please open an issue on the AWS Graviton Technical Guide &lt;a href=&quot;https://github.com/aws/aws-graviton-getting-started&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;acknowledgements&quot;&gt;Acknowledgements&lt;/h2&gt;

&lt;p&gt;We would like to thank the PyTorch community for the baseline torch.compile framework and their continued efforts to optimize it further.&lt;/p&gt;

&lt;p&gt;References:  &lt;a href=&quot;https://pytorch.org/assets/pytorch2-2.pdf&quot;&gt;https://pytorch.org/assets/pytorch2-2.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;author&quot;&gt;Author&lt;/h2&gt;

&lt;p&gt;Sunita Nadampalli is a Software Development Manager and AI/ML expert at AWS. She leads AWS Graviton software performance optimizations for AI/ML and HPC workloads. She is passionate about open source software development and delivering high-performance and sustainable software solutions for SoCs based on the Arm ISA.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sunita Nadampalli</name>
        
        
      </author>

      

      

      
        <summary type="html">Summary</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Announcing Hacker Cup AI Track at NeurIPS 2024</title>
      <link href="https://pytorch.org/blog/hacker-cup/" rel="alternate" type="text/html" title="Announcing Hacker Cup AI Track at NeurIPS 2024" />
      <published>2024-07-03T00:00:00-07:00</published>
      <updated>2024-07-03T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/hacker-cup</id>
      <content type="html" xml:base="https://pytorch.org/blog/hacker-cup/">&lt;p&gt;The PyTorch team in partnership with Meta Hacker Cup, and Microsoft Research, are excited to announce the Hacker Cup AI Track at NeurIPS 2024. This will be the first AI track for the popular Meta Hacker Cup programming competition designed to assess the capabilities of Generative AI in performing autonomous code generation tasks. We aim to test the limits of AI in complex coding challenges and measure the performance gap between AI systems and human programmers. We will provide access to all Hacker Cup problems since 2011 alongside their respective solutions in a multimodal (image and text) format, and utilize the existing Hacker Cup infrastructure for competitor evaluation. Featuring both &lt;em&gt;open evaluation, open model&lt;/em&gt; and &lt;em&gt;open evaluation, closed model&lt;/em&gt; tracks, this competition invites diverse participation from research institutions of varied interests and resource constraints, including academic labs, AI startups, large technology companies, and AI enthusiasts. Our goal is to develop and democratize meaningful advancements in code automation with the very first open evaluation process for competitive AI programmers. Registration will begin in &lt;strong&gt;Early August&lt;/strong&gt;, with our first qualification round on &lt;strong&gt;September 20th.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For more information please visit our website at &lt;a href=&quot;https://www.facebook.com/codingcompetitions/hacker-cup/&quot;&gt;https://www.facebook.com/codingcompetitions/hacker-cup/&lt;/a&gt; &lt;strong&gt;and join our Discord&lt;/strong&gt; at &lt;a href=&quot;https://discord.com/invite/wWeN9hTH32&quot;&gt;discord.gg/wWeN9hTH32&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Facebook</name>
        
        
      </author>

      

      

      
        <summary type="html">The PyTorch team in partnership with Meta Hacker Cup, and Microsoft Research, are excited to announce the Hacker Cup AI Track at NeurIPS 2024. This will be the first AI track for the popular Meta Hacker Cup programming competition designed to assess the capabilities of Generative AI in performing autonomous code generation tasks. We aim to test the limits of AI in complex coding challenges and measure the performance gap between AI systems and human programmers. We will provide access to all Hacker Cup problems since 2011 alongside their respective solutions in a multimodal (image and text) format, and utilize the existing Hacker Cup infrastructure for competitor evaluation. Featuring both open evaluation, open model and open evaluation, closed model tracks, this competition invites diverse participation from research institutions of varied interests and resource constraints, including academic labs, AI startups, large technology companies, and AI enthusiasts. Our goal is to develop and democratize meaningful advancements in code automation with the very first open evaluation process for competitive AI programmers. Registration will begin in Early August, with our first qualification round on September 20th.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Powering the AI Revolution: The PyTorch Documentary</title>
      <link href="https://pytorch.org/blog/pytorch-documentary/" rel="alternate" type="text/html" title="Powering the AI Revolution: The PyTorch Documentary" />
      <published>2024-06-25T00:00:00-07:00</published>
      <updated>2024-06-25T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/pytorch-documentary</id>
      <content type="html" xml:base="https://pytorch.org/blog/pytorch-documentary/">&lt;p&gt;Now live: The official &lt;a href=&quot;https://www.youtube.com/live/EjgTv6aSeqk&quot;&gt;PyTorch Documentary&lt;/a&gt;! This film unveils the authentic narrative of PyTorch’s inception, attributing its existence to a dedicated group of unsung heroes driving technological innovation.&lt;/p&gt;

&lt;p&gt;The documentary shares the strength of the PyTorch community, resonating with our communities across the globe. We hope this story of PyTorch inspires greater contributions, attracts more contributors to the project, and fosters widespread recognition of PyTorch’s significance in the open source community.&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/EjgTv6aSeqk?si=GKGvwuY7VA9iPGKm&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen=&quot;&quot; class=&quot;mb-5 mt-3&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;We couldn’t have produced this without the support of our PyTorch Foundation members and sponsors:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/doc-logos.jpg&quot; alt=&quot;company logos&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;amd&quot;&gt;AMD&lt;/h3&gt;

&lt;p&gt;“PyTorch’s growth and adoption in the AI community is a testament to open collaboration. The collective efforts of all the contributors have helped propel PyTorch as one of the most widely adopted AI frameworks in the industry. AMD is proud to be a part of this movement - making sure that the future of AI is open - and we are excited to continue contributing to this vibrant ecosystem.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Niles Burbank, AMD&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;aws&quot;&gt;AWS&lt;/h3&gt;

&lt;p&gt;“The release of the PyTorch Documentary showcases the innovation and real-world impact of one of the most widely adopted open source machine learning frameworks. By supporting and contributing to the PyTorch community, AWS helps enable cutting-edge machine learning research that drives advancements in AI capabilities. We are excited about the documentary as it highlights the power of collaboration in propelling PyTorch to the forefront of machine learning and empowering developers and data scientists to create groundbreaking models. At AWS, we celebrate frameworks like PyTorch that foster environments where open source machine learning technologies can grow and benefit the community at-large, as well as our customers.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Brian Granger, AWS&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;google-cloud&quot;&gt;Google Cloud&lt;/h3&gt;

&lt;p&gt;“Google recognizes the impact of PyTorch on the AI community, providing researchers and developers with powerful, flexible tools for innovation. This documentary not only celebrates the remarkable achievements of the PyTorch community but also highlights the collaborative spirit driving advancements in AI. We look forward to continuing our support for PyTorch and fostering an open ecosystem that accelerates machine learning research and application.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Dwarak Rajagopal, Google&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;meta&quot;&gt;Meta&lt;/h3&gt;

&lt;p&gt;“We have been so impressed with the growth and collaboration that PyTorch has created over the years. From very humble beginnings at Meta to a cornerstone in AI research and development, the documentary showcases the dedication of our contributors since the start. It’s an honor to be a part of something so impactful, and now it’s been documented for our community to take part in.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Soumith Chintala, Meta&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;microsoft-azure&quot;&gt;Microsoft Azure&lt;/h3&gt;

&lt;p&gt;“We’re truly excited about the premiere of the PyTorch Documentary. At Microsoft, PyTorch has been our default deep learning framework for building AI solutions including Microsoft Copilot. Additionally, we have made significant investments to create an optimized environment for our customers to develop, train, fine-tune and deploy their PyTorch workloads on Azure and Windows, furthering our commitment to democratize AI.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Eric Boyd, Microsoft&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;pytorch-foundation&quot;&gt;PyTorch Foundation&lt;/h3&gt;

&lt;p&gt;“The release of the PyTorch documentary marks a significant milestone for our community, showcasing the incredible journey and rapid evolution of PyTorch. We are excited to share these stories and achievements with the world, and we look forward to continuing to foster innovation and growth of the PyTorch community and PyTorch’s evolving ecosystem.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;– Matt White, PyTorch Foundation&lt;/strong&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>The PyTorch Foundation</name>
        
        
      </author>

      

      

      
        <summary type="html">Now live: The official PyTorch Documentary! This film unveils the authentic narrative of PyTorch’s inception, attributing its existence to a dedicated group of unsung heroes driving technological innovation.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Training MoEs at Scale with PyTorch</title>
      <link href="https://pytorch.org/blog/training-moes/" rel="alternate" type="text/html" title="Training MoEs at Scale with PyTorch" />
      <published>2024-06-23T00:00:00-07:00</published>
      <updated>2024-06-23T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/training-moes</id>
      <content type="html" xml:base="https://pytorch.org/blog/training-moes/">&lt;p&gt;Over the past year, Mixture of Experts (MoE) models have surged in popularity, fueled by powerful open-source models like &lt;a href=&quot;https://www.databricks.com/blog/introducing-dbrx-new-state-art-open-llm&quot;&gt;DBRX&lt;/a&gt;, &lt;a href=&quot;https://mistral.ai/news/mixtral-of-experts/&quot;&gt;Mixtral&lt;/a&gt;, &lt;a href=&quot;https://github.com/deepseek-ai/DeepSeek-V2&quot;&gt;DeepSeek&lt;/a&gt;, and many more. At Databricks, we’ve worked closely with the PyTorch team to scale training of MoE models. In this blog post, we’ll talk about how we scale to over three thousand GPUs using &lt;a href=&quot;https://pytorch.org/tutorials/beginner/dist_overview.html&quot;&gt;PyTorch Distributed&lt;/a&gt; and &lt;a href=&quot;https://github.com/databricks/megablocks&quot;&gt;MegaBlocks&lt;/a&gt;, an efficient open-source MoE implementation in PyTorch.&lt;/p&gt;

&lt;h2 id=&quot;what-is-a-moe&quot;&gt;What is a MoE?&lt;/h2&gt;

&lt;p&gt;A MoE model is a model architecture that uses multiple expert networks to make predictions. A gating network is used to route and combine the outputs of experts, ensuring each expert is trained on a different, specialized distribution of tokens. The architecture of a transformer-based large language model typically consists of an embedding layer that leads into multiple transformer blocks (Figure 1, Subfigure A). Each transformer block contains an attention block and a dense feed forward network (Figure 1, Subfigure B). These transformer blocks are stacked such that the output of one transformer block leads to the input of the next block. The final output goes through a fully connected layer and softmax to obtain probabilities for the next token to output.&lt;/p&gt;

&lt;p&gt;When using a MoE in LLMs, the dense feed forward layer is replaced by a MoE layer which consists of a gating network and a number of experts (Figure 1, Subfigure D). The gating network, typically a linear feed forward network, takes in each token and produces a set of weights that determine which tokens are routed to which experts. The experts themselves are typically implemented as a feed forward network as well. During training, the gating network adapts to assign inputs to the experts, enabling the model to specialize and improve its performance. The router outputs are then used to weigh expert outputs to give the final output of the MoE layer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/training-moes/fg1.png&quot; alt=&quot;Figure 1: Using Mixture of Experts in a transformer block&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 1: Using Mixture of Experts in a transformer block&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Compared to dense models, MoEs provide more efficient training for a given compute budget. This is because the gating network only sends tokens to a subset of experts, reducing the computational load. As a result, the capacity of a model (its total number of parameters) can be increased without proportionally increasing the computational requirements. During inference, only some of the experts are used, so a MoE is able to perform faster inference than a dense model. However, the entire model needs to be loaded in memory, not just the experts being used.&lt;/p&gt;

&lt;p&gt;The sparsity in MoEs that allows for greater computational efficiency comes from the fact that a particular token will only be routed to a subset of experts. The number of experts and how experts are chosen depends on the implementation of the gating network, but a common method is top k. The gating network first predicts a probability value for each expert, then routes the token to the top k experts to obtain the output. However, if all tokens always go to the same subset of experts, training becomes inefficient and the other experts end up undertrained. To alleviate this problem, a load balancing loss is introduced that encourages even routing to all experts.&lt;/p&gt;

&lt;p&gt;The number of experts and choosing the top k experts is an important factor in designing MoEs. A higher number of experts allows scaling up to larger models without increasing computational cost. This means that the model has a higher capacity for learning, however, past a certain point the performance gains tend to diminish. The number of experts chosen needs to be balanced with the inference costs of serving the model since the entire model needs to be loaded in memory. Similarly, when choosing top k, a lower top k during training results in smaller matrix multiplications, leaving free computation on the table if communication costs are large enough. During inference, however, a higher top k generally leads to slower inference speed.&lt;/p&gt;

&lt;h2 id=&quot;megablocks&quot;&gt;MegaBlocks&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/databricks/megablocks&quot;&gt;MegaBlocks&lt;/a&gt; is an efficient MoE implementation that uses sparse matrix multiplication to compute expert outputs in parallel despite uneven token assignment. MegaBlocks implements a dropless MoE that avoids dropping tokens while using GPU kernels that maintain efficient training. Prior to MegaBlocks, dynamic routing formulations forced a tradeoff between model quality and hardware efficiency. Previously, users had to either drop tokens from computation or waste computation and memory on padding. Experts can receive a variable number of tokens and the expert computation can be performed efficiently using block sparse matrix multiplication. We’ve &lt;a href=&quot;https://www.databricks.com/blog/bringing-megablocks-databricks&quot;&gt;integrated MegaBlocks into LLM Foundry&lt;/a&gt; to enable scaling MoE training to thousands of GPUs.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/training-moes/fg2.png&quot; alt=&quot;Figure 2: Matrix multiplication for expert computations&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 2: Matrix multiplication for expert computations&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;expert-parallelism&quot;&gt;Expert Parallelism&lt;/h3&gt;

&lt;p&gt;As models scale to larger sizes and fail to fit on a single GPU, we require more advanced forms of parallelism. Expert parallelism is a form of model parallelism where we place different experts on different GPUs for better performance. Instead of expert weights being communicated across all GPUs, tokens are sent to the device that contains the expert. By moving data instead of weights, we can aggregate data across multiple machines for a single expert. The router determines which tokens from the input sequence should be sent to which experts. This is typically done by computing a gating score for each token-expert pair, and then routing each token to the top-scoring experts. Once the token-to-expert assignments are determined, an all-to-all communication step is performed to dispatch the tokens to the devices hosting the relevant experts. This involves each device sending the tokens assigned to experts on other devices, while receiving tokens assigned to its local experts.&lt;/p&gt;

&lt;p&gt;The key advantage of expert parallelism is processing a few, larger matrix multiplications instead of several small matrix multiplications. As each GPU only has a subset of experts, it only has to do computation for those experts. Correspondly, as we aggregate tokens across multiple GPUs, the size of each matrix is proportionally larger. As GPUs are optimized for large-scale parallel computations, larger operations can better exploit their capabilities, leading to higher utilization and efficiency. A more in depth explanation of the benefits of larger matrix multiplications can be found &lt;a href=&quot;https://www.thonking.ai/p/what-shapes-do-matrix-multiplications&quot;&gt;here&lt;/a&gt;. Once the computation is complete, another all-to-all communication step is performed to send the expert outputs back to their original devices.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/training-moes/fg3.png&quot; alt=&quot;Figure 3: Token routing in expert parallelism&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 3: Token routing in expert parallelism&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We leverage PyTorch’s &lt;a href=&quot;https://github.com/pytorch/pytorch/blob/main/torch/distributed/_tensor/README.md&quot;&gt;DTensor&lt;/a&gt;, a low-level abstraction for describing how tensors are sharded and replicated, to effectively implement expert parallelism. We first manually place experts on different GPUs, typically sharding across a node to ensure we can leverage NVLink for fast GPU communication when we route tokens. We can then build a &lt;a href=&quot;https://pytorch.org/tutorials/recipes/distributed_device_mesh.html&quot;&gt;device mesh&lt;/a&gt; on top of this layout, which lets us succinctly describe the parallelism across the entire cluster. We can use this device mesh to easily checkpoint or rearrange experts when we need alternate forms of parallelism.&lt;/p&gt;

&lt;h3 id=&quot;scaling-zero-3-with-pytorch-fsdp&quot;&gt;Scaling ZeRO-3 with PyTorch FSDP&lt;/h3&gt;

&lt;p&gt;In conjunction with expert parallelism, we use data parallelism for all other layers, where each GPU stores a copy of the model and optimizer and processes a different chunk of data. After each GPU has completed a forward and backward pass, gradients are accumulated across GPUs for a global model update.&lt;/p&gt;

&lt;p&gt;ZeRO-3 is a form of data parallelism where weights and optimizers are sharded across each GPU instead of being replicated. Each GPU now only stores a subset of the full model, dramatically reducing memory pressure. When a part of the model is needed for computation, it is gathered across all the GPUs, and after the computation is complete, the gathered weights are discarded. We use PyTorch’s implementation of ZeRO-3, called &lt;a href=&quot;https://pytorch.org/blog/introducing-pytorch-fully-sharded-data-parallel-api/&quot;&gt;Fully Sharded Data Parallel (FSDP)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we scale to thousands of GPUs, the cost of communication across devices increases, slowing down training. Communication increases due to the need to synchronize and share model parameters, gradients, and optimizer states across all GPUs which involves all-gather and reduce-scatter operations. To mitigate this issue while keeping the benefits of FSDP, we utilize Hybrid Sharded Data Parallel (HSDP) to shard the model and optimizer across a set number of GPUs and replicate this multiple times to fully utilize the cluster. With HSDP, an additional all reduce operation is needed in the backward pass to sync gradients across replicas. This approach allows us to balance memory efficiency and communication cost during large scale distributed training. To use HSDP we can extend our previous device mesh from expert parallelism and let PyTorch do the heavy lifting of actually sharding and gathering when needed.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/training-moes/fg4.png&quot; alt=&quot;Figure 4: FSDP and HSDP&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 4: FSDP and HSDP&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;With PyTorch, we can effectively combine these two types of parallelism, leveraging FSDP’s higher level API while using the lower-level &lt;a href=&quot;https://github.com/pytorch/pytorch/blob/main/torch/distributed/_tensor/README.md&quot;&gt;DTensor&lt;/a&gt; abstraction when we want to implement something custom like expert parallelism. We now have a 3D device mesh with expert parallel shard dimension, ZeRO-3 shard dimension, and a replicate dimension for pure data parallelism. Together, these techniques deliver near linear scaling across very large clusters, allowing us to achieve MFU numbers over 40%.&lt;/p&gt;

&lt;h3 id=&quot;elastic-checkpointing-with-torch-distributed&quot;&gt;Elastic Checkpointing with Torch Distributed&lt;/h3&gt;

&lt;p&gt;Fault tolerance is crucial for ensuring that LLMs can be trained reliably over extended periods, especially in distributed environments where node failures are common. To avoid losing progress when jobs inevitably encounter failures, we checkpoint the state of the model, which includes parameters, optimizer states, and other necessary metadata. When a failure occurs, the system can resume from the last saved state rather than starting over. To ensure robustness to failures, we need to checkpoint often and save and load checkpoints in the most performant way possible to minimize downtime. Additionally, if too many GPUs fail, our cluster size may change. Accordingly, we need the ability to elastically resume on a different number of GPUs.&lt;/p&gt;

&lt;p&gt;PyTorch supports elastic checkpointing through its distributed training framework, which includes utilities for both saving and loading checkpoints across different cluster configurations. PyTorch Distributed Checkpoint ensures the model’s state can be saved and restored accurately across all nodes in the training cluster in parallel, regardless of any changes in the cluster’s composition due to node failures or additions.&lt;/p&gt;

&lt;p&gt;Additionally, when training very large models, the size of checkpoints may be very large, leading to very slow checkpoint upload and download times. PyTorch Distributed Checkpoint supports sharded checkpoints, which enables each GPU to save and load only its portion of the model. When combining sharded checkpointing with elastic training, each GPU reads the metadata file to determine which shards to download on resumption. The metadata file contains information on what parts of each tensor are stored in each shard. The GPU can then download the shards for its part of the model and load that part of the checkpoint.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/training-moes/fg5.png&quot; alt=&quot;Figure 5: Checkpointing saving and resumption resharded on additional GPUs&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 5: Checkpointing saving and resumption resharded on additional GPUs&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;By parallelizing checkpointing across GPUs, we can spread out network load, improving robustness and speed. When training a model with 3000+ GPUs, network bandwidth quickly becomes a bottleneck. We take advantage of the replication in HSDP to first download checkpoints on one replica and then send the necessary shards to other replicas. With our integration in &lt;a href=&quot;https://github.com/mosaicml/composer&quot;&gt;Composer&lt;/a&gt;, we can reliably upload checkpoints to cloud storage as frequently as every 30 minutes and automatically resume from the latest checkpoint in the event of a node failure in less than 5 minutes.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;We’re very excited to see how PyTorch is enabling training state-of-the-art LLMs with great performance. In our post, we’ve shown how we implemented efficient MoE training through Pytorch Distributed and MegaBlocks on Foundry. Furthermore, Pytorch elastic checkpointing allowed us to quickly resume training on a different number of GPUs when node failures occurred. Using Pytorch HSDP has allowed us to scale training efficiently as well as improve checkpointing resumption times. We look forward to continuing building on a strong and vibrant open-source community to help bring great AI models to everyone. Come join us in building great models at &lt;a href=&quot;https://github.com/mosaicml/llm-foundry&quot;&gt;LLM Foundry&lt;/a&gt; and &lt;a href=&quot;https://github.com/pytorch/pytorch&quot;&gt;PyTorch&lt;/a&gt;.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Brian Chu, Mihir Patel, Less Wright, Vitaliy Chiley, Evan Racah, Wanchao Liang, Iris Zhang, Andrew Gu</name>
        
        
      </author>

      

      

      
        <summary type="html">Over the past year, Mixture of Experts (MoE) models have surged in popularity, fueled by powerful open-source models like DBRX, Mixtral, DeepSeek, and many more. At Databricks, we’ve worked closely with the PyTorch team to scale training of MoE models. In this blog post, we’ll talk about how we scale to over three thousand GPUs using PyTorch Distributed and MegaBlocks, an efficient open-source MoE implementation in PyTorch.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Accelerating Neural Network Training with Semi-Structured (2:4) Sparsity</title>
      <link href="https://pytorch.org/blog/accelerating-neural-network-training/" rel="alternate" type="text/html" title="Accelerating Neural Network Training with Semi-Structured (2:4) Sparsity" />
      <published>2024-06-20T00:00:00-07:00</published>
      <updated>2024-06-20T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/accelerating-neural-network-training</id>
      <content type="html" xml:base="https://pytorch.org/blog/accelerating-neural-network-training/">&lt;p&gt;Over the past year, we’ve added support for semi-structured (2:4) sparsity into PyTorch. With just a few lines of code, we were able to show a 10% end-to-end inference speedup on &lt;a href=&quot;https://github.com/pytorch/ao/tree/main/torchao/sparsity#segment-anything&quot;&gt;segment-anything&lt;/a&gt; by replacing dense matrix multiplications with sparse matrix multiplications.&lt;/p&gt;

&lt;p&gt;However, matrix multiplications are not unique to neural network inference - they happen during training as well. By expanding on the core primitives we used earlier to accelerate inference, we were also able to accelerate model training. We wrote a replacement nn.Linear layer, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SemiSparseLinear&lt;/code&gt;, that is able to achieve a 1.3x &lt;a href=&quot;https://github.com/pytorch/ao/tree/main/torchao/sparsity/training#benchmarking&quot;&gt;speedup&lt;/a&gt; across the forwards + backwards pass of the linear layers in the MLP block of ViT-L on a NVIDIA A100.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;End-to-end, we see a wall time reduction of 6% for a &lt;a href=&quot;https://github.com/facebookresearch/dinov2&quot;&gt;DINOv2 ViT-L&lt;/a&gt; training, with virtually no accuracy degradation out of the box (82.8 vs 82.7 on ImageNet top-1 accuracy).&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg1.png&quot; alt=&quot;2 strategies for training a ViT model&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;We compare 2 strategies for training a ViT model for 125k iterations on 4x NVIDIA A100s: either fully dense (blue), or sparse for 70% of the training, then dense (orange). Both achieve similar results on the benchmarks, but the sparse variant trains 6% faster. For both experiments, we evaluate the intermediate checkpoints with and without sparsity.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;As far as we are aware, &lt;strong&gt;this is the first OSS implementation of accelerated sparse training&lt;/strong&gt; and we’re excited to provide a user API in &lt;a href=&quot;https://github.com/pytorch/ao/tree/main/torchao/sparsity/training#benchmarking&quot;&gt;torchao&lt;/a&gt;. You can try accelerating your own training runs with just a few lines of code:&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Requires torchao and pytorch nightlies and CUDA compute capability 8.0+
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torch&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;torchao.sparsity.training&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SemiSparseLinear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;swap_linear_with_semi_sparse_linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sequential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;torch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cuda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;half&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Specify the fully-qualified-name of the nn.Linear modules you want to swap
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sparse_config&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;seq.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SemiSparseLinear&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Swap nn.Linear with SemiSparseLinear, you can run your normal training loop after this step
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap_linear_with_semi_sparse_linear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sparse_config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;how-does-this-work&quot;&gt;How does this work?&lt;/h2&gt;

&lt;p&gt;The general idea behind sparsity is simple: skip calculations involving zero-valued tensor elements to speed up matrix multiplication. However, simply setting weights to zero isn’t enough, as the dense tensor still contains these pruned elements and dense matrix multiplication kernels will continue to process them, incurring the same latency and memory overhead. To achieve actual performance gains, we need to replace dense kernels with sparse kernels that intelligently bypass calculations involving pruned elements.&lt;/p&gt;

&lt;p&gt;These kernels work on sparse matrices, which remove the pruned elements and store the specified elements in a compressed format. There are many different sparse formats, but we’re particularly interested in &lt;strong&gt;semi-structured sparsity,&lt;/strong&gt; also known as &lt;strong&gt;2:4 structured sparsity&lt;/strong&gt; or &lt;strong&gt;fine-grained structured sparsity&lt;/strong&gt; or more generally &lt;strong&gt;N:M structured sparsity&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg2.png&quot; alt=&quot;2:4 sparse compressed representation&quot; style=&quot;width:100%;display:block;max-width:600px;margin-left:auto;margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2:4 sparse compressed representation. Original &lt;a href=&quot;https://developer.nvidia.com/blog/structured-sparsity-in-the-nvidia-ampere-architecture-and-applications-in-search-engines/&quot;&gt;Source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A 2:4-sparse matrix is a matrix where at most 2 elements are non-zero for every 4 elements, as illustrated in the image above. Semi-structured sparsity is attractive because it exists in a goldilocks spot of performance and accuracy:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;NVIDIA GPUs since Ampere offer hardware acceleration and library support (&lt;a href=&quot;https://docs.nvidia.com/cuda/cusparselt/index.html&quot;&gt;cuSPARSELt&lt;/a&gt;) for this format, with matrix multiplication being up to 1.6x faster&lt;/li&gt;
  &lt;li&gt;Pruning models to fit this sparsity pattern does not degrade accuracy as much as other patterns. NVIDIA’s &lt;a href=&quot;https://arxiv.org/pdf/2104.08378&quot;&gt;whitepaper&lt;/a&gt; shows pruning then retraining is able to recover accuracy for most vision models.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg3.png&quot; alt=&quot;Illustration of 2:4 (sparse) matrix multiplication on NVIDIA GPUs&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Illustration of 2:4 (sparse) matrix multiplication on NVIDIA GPUs. Original &lt;a href=&quot;https://arxiv.org/pdf/2104.08378&quot;&gt;source&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Accelerating inference with semi-structured sparsity is straightforward. Since our weights are fixed during inference, we can prune and compress the weight ahead of time (offline) and store the compressed sparse representation instead of our dense tensor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg4.png&quot; alt=&quot;flow chart&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Then, instead of dispatching to dense matrix multiplication we dispatch to sparse matrix multiplication, passing in the compressed sparse weight instead of the normal dense one. For more information about accelerating models for inference using 2:4 sparsity, please refer to our &lt;a href=&quot;https://pytorch.org/tutorials/advanced/semi_structured_sparse.html?highlight=beta&quot;&gt;tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;extending-sparse-inference-acceleration-to-training&quot;&gt;Extending sparse inference acceleration to training&lt;/h2&gt;

&lt;p&gt;In order to use sparsity to reduce the training time of our models, we need to consider when the mask is calculated, as once we store the compressed representation the mask is fixed.&lt;/p&gt;

&lt;p&gt;Training with a fixed mask applied to an existing trained dense model (also known as &lt;strong&gt;pruning&lt;/strong&gt;) does not degrade accuracy, but this requires two training runs - one to obtain the dense model and another to make it sparse, offering no speedups.&lt;/p&gt;

&lt;p&gt;Instead we’d like to train a sparse model from scratch (&lt;strong&gt;dynamic sparse training&lt;/strong&gt;), but training from scratch with a fixed mask will lead to a significant drop in evaluations, as the sparsity mask would be selected at initialization, when the model weights are essentially random.&lt;/p&gt;

&lt;p&gt;To maintain the accuracy of the model when training from scratch, we prune and compress the weights at runtime, so that we can calculate the optimal mask at each step of the training process.&lt;/p&gt;

&lt;p&gt;Conceptually you can think of our approach as an approximate matrix multiplication technique, where we &lt;code&gt;`prune_and_compress`&lt;strong&gt; &lt;/strong&gt;&lt;/code&gt;and dispatch to &lt;code&gt;`sparse_GEMM`&lt;/code&gt; in less time than a &lt;code&gt;`dense_GEMM`&lt;/code&gt; call would take. This is difficult because the native pruning and compression functions are too slow to show speedups.&lt;/p&gt;

&lt;p&gt;Given the shapes of our ViT-L training matrix multiplications (13008x4096x1024), we measured the runtime of a dense and sparse GEMM respectively at 538us and 387us. In other words, the pruning and compression step of the weight matrix must run in less than 538-387=151us to have any efficiency gain. Unfortunately, the compression kernel provided in cuSPARSELt already takes 380us (without even considering the pruning step!).&lt;/p&gt;

&lt;p&gt;Given the max NVIDIA A100 memory IO (2TB/s), and considering that a prune and compress kernel would be memory bound, we could theoretically prune and compress our weight (4096x1024x2 bytes=8MB) in 4us (8MB / 2TB/s)! And in fact, we were able to write a kernel that prunes and compresses a matrix into 2:4-sparse format, and runs in 36 us (10x faster than the compression kernel in cuSPARSELt), making the entire GEMM (including the sparsification) faster. Our kernel is &lt;a href=&quot;https://github.com/pytorch/pytorch/pull/122350&quot;&gt;available&lt;/a&gt; for use in PyTorch.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg5.png&quot; alt=&quot;Our custom sparsification kernel&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Our custom sparsification kernel, which includes pruning + compression, is ~30% faster across a linear layer forward+backward. Benchmarks run on a NVIDIA A100-80GB GPU.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;writing-a-performant-runtime-sparsification-kernel&quot;&gt;Writing a performant runtime sparsification kernel&lt;/h3&gt;

&lt;p&gt;There were multiple challenges we faced in order to implement a performant runtime sparsification kernel, which we will explore below.&lt;/p&gt;

&lt;h4 id=&quot;1-handling-the-backwards-pass&quot;&gt;1) Handling the backwards pass&lt;/h4&gt;

&lt;p&gt;For the backwards pass, we need to calculate dL/dX and dL/dW for the gradient update and the subsequent layer, which means we need to calculate xW&lt;sup&gt;T&lt;/sup&gt; and x&lt;sup&gt;T&lt;/sup&gt;W respectively.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg6.png&quot; alt=&quot;Overview of runtime sparsification for training acceleration (FW + BW pass)&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Overview of runtime sparsification for training acceleration (FW + BW pass)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;However this is problematic, because the compressed representation cannot be transposed, since there’s no guarantee that the tensor is 2:4 sparse in both directions.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg7.png&quot; alt=&quot;Both matrices are valid 2:4 matrices. However, the right one is no longer a valid 2:4 matrix once transposed because one column contains more than 2 elements&quot; style=&quot;width:100%;display:block;max-width:500px;margin-left:auto;margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Both matrices are valid 2:4 matrices. However, the right one is no longer a valid 2:4 matrix once transposed because one column contains more than 2 elements&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Therefore, we prune a 4x4 tile, instead of a 1x4 strip. We greedily preserve the largest values, ensuring that we take at most 2 values for each row / column. While this approach is not guaranteed to be optimal, as we sometimes only preserve 7 values instead of 8, it efficiently calculates a tensor that is 2:4 sparse both row-wise and column-wise.&lt;/p&gt;

&lt;p&gt;We then compress both the packed tensor and the packed transpose tensor, storing the transpose tensor for the backwards pass. By calculating both the packed and packed transpose tensor at the same time, we avoid a secondary kernel call in the backwards pass.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg8.png&quot; alt=&quot;Our kernel prunes the weight matrix in registers&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Our kernel prunes the weight matrix in registers, and writes the compressed values in global memory. It also prunes at the same time W.t, which is needed for the backward pass, minimizing the memory IO&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There’s some additional transpose trickery needed to handle the backwards pass - the underlying hardware only supports operations where the first matrix is sparse. For weight sparsification during inference, when we need to calculate xW&lt;sup&gt;T&lt;/sup&gt; we rely on transpose properties to swap the order of the operands.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg1.jpg&quot; alt=&quot;Math formula&quot; style=&quot;width:100%;display:block;max-width:300px;margin-left:auto;margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;During inference, we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;torch.compile&lt;/code&gt; to fuse the outer transpose into subsequent pointwise ops in order to avoid paying a performance penalty.&lt;/p&gt;

&lt;p&gt;However in the case of the backwards pass of training, we have no subsequent pointwise op to fuse with. Instead, we fuse the transposition into our matrix multiplication by taking advantage of cuSPARSELt’s ability to specify the row / column layout of the result matrix.&lt;/p&gt;

&lt;h4 id=&quot;2-kernel-tiling-for-efficient-memory-io&quot;&gt;2) Kernel tiling for efficient memory-IO&lt;/h4&gt;

&lt;p&gt;In order for our kernel to be as efficient as possible, we want to coalesce our reads / writes, as we found that memory IO to be the main bottleneck. This means that within a CUDA thread, we want to read/write chunks of 128 bytes at a time, so that multiple parallel reads/writes can be coalesced into a single request by the GPU memory controller.&lt;/p&gt;

&lt;p&gt;Therefore, instead of a thread handling a single 4x4 tile, which is only 4x4x2 = 32 bytes, we decided that each thread will handle 4 4x4 tiles (aka an 8x8 tile), which allows us to operate 8x8x2 =128 byte chunks.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg9.png&quot; alt=&quot;Kernel tiling for efficient memory-IO&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-sorting-elements-in-a-4x4-tile-without-warp-divergence&quot;&gt;3) Sorting elements in a 4x4 tile without warp-divergence&lt;/h4&gt;

&lt;p&gt;For each individual 4x4 tile within our thread we calculate a bitmask that specifies which elements to prune and which elements to keep. To do this we sort all 16 elements and greedily preserve elements, so long as they do not break our 2:4 row / col constraint. This preserves only the weights with the largest values.&lt;/p&gt;

&lt;p&gt;Crucially we observe that we are only ever sorting a fixed number of elements, so by using a branchless &lt;a href=&quot;https://en.wikipedia.org/wiki/Sorting_network&quot;&gt;sorting network&lt;/a&gt;, we can avoid warp divergence.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg10.png&quot; alt=&quot;Sorting network diagram&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;For clarity, the transposed packed tensor and metadata are omitted. Sorting network diagram taken from &lt;a href=&quot;https://en.wikipedia.org/wiki/Sorting_network&quot;&gt;Wikipedia&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Warp divergence occurs when we have conditional execution inside across a thread block. In CUDA, work items in the same work group (thread block) are dispatched at the hardware level in batches (warps). If we have conditional execution, such that some work-items in the same batch run different instructions, then they are masked when the warp is dispatched, or dispatched sequentially.&lt;/p&gt;

&lt;p&gt;For example, if we have some code like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if (condition) do(A) else do(B)&lt;/code&gt;, where condition is satisfied by all the odd-numbered work items, then the total runtime of this conditional statement is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do(A) + do(B)&lt;/code&gt;, since we would dispatch &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do(A)&lt;/code&gt; for all odd-numbered work-items, masking out even-numbered work-items, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do(B)&lt;/code&gt; for all even numbered work-items, masking out odd-numbered work-items. This &lt;a href=&quot;https://www.reddit.com/r/CUDA/comments/gkpjxe/what_is_warp_divergence/#:~:text=Warp%20divergence%20is%20a%20%22Compute,later%20processed%20using%20different%20instructions.&quot;&gt;answer&lt;/a&gt; provides more information about warp divergence.&lt;/p&gt;

&lt;h4 id=&quot;4-writing-the-compressed-matrices-and-metadata&quot;&gt;4) Writing the compressed matrices and metadata&lt;/h4&gt;

&lt;p&gt;Once the bitmask has been computed, the weight data has to be written back in a compressed format in global memory. This is not trivial, because the data needs to stay in registers, and it’s not possible to index registers (eg &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C[i++] = a&lt;/code&gt; prevents us from storing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt; in registers). Furthermore, we found that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvcc&lt;/code&gt; was using many more registers than we expected, which caused register spilling and impacted global performance. We write this compressed matrix to global memory in Column-Major format to make the writes more efficient.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg11.png&quot; alt=&quot;compressed matrix to global memory in Column-Major format&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We also need to write the cuSPARSELt metadata as well. This metadata layout is quite similar to the one from the open-source CUTLASS library and is optimized for being loaded efficiently through shared-memory in the GEMM kernel with the PTX &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ldmatrix&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;However, this layout is not optimized to be written efficiently: the first 128 bits of the metadata tensor contains metadata about the first 32 columns of the rows 0, 8, 16 and 24. Recall that each thread handles an 8x8 tile, which means that this information is scattered across 16 threads.&lt;/p&gt;

&lt;p&gt;We rely on a series of warp-shuffle operations, once for the original and transposed representation respectively to write the metadata. Fortunately, this data represents less than 10% of the total IO, so we can afford to not fully coalesce the writes.&lt;/p&gt;

&lt;h2 id=&quot;dinov2-sparse-training-experimental-setup-and-results&quot;&gt;DINOv2 Sparse Training: Experimental Setup and Results&lt;/h2&gt;

&lt;p&gt;For our experiments, the ViT-L model is trained on ImageNet for 125k steps using the DINOv2 method. All our experiments were run on 4x AMD EPYC 7742 64-core CPUs and 4x NVIDIA A100-80GB GPUs. During sparse training, the model is trained with 2:4 sparsity enabled for the first part of the training, where only half of the weights are enabled. This sparsity mask on the weights is dynamically recomputed at every step, as weights are continuously updated during the optimization. For the remaining steps, the model is trained densely, producing a final model without 2:4 sparsity (except the 100% sparse training setup), which is then evaluated.&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;Training setup
   &lt;/td&gt;
   &lt;td&gt;ImageNet 1k log-regression
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;0% sparse (125k dense steps, baseline)
   &lt;/td&gt;
   &lt;td&gt;82.8
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;40% sparse (50k sparse -&amp;gt; 75k dense steps)
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;82.9&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;60% sparse (75k sparse -&amp;gt; 50k dense steps)
   &lt;/td&gt;
   &lt;td&gt;82.8
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;70% sparse (87.5k sparse -&amp;gt; 37.5k dense steps)
   &lt;/td&gt;
   &lt;td&gt;82.7
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;80% sparse (100k sparse -&amp;gt; 25k dense steps)
   &lt;/td&gt;
   &lt;td&gt;82.7
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;90% sparse (112.5k sparse -&amp;gt; 12.5k dense steps)
   &lt;/td&gt;
   &lt;td&gt;82.0
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;100% sparse (125k sparse steps) 
   &lt;/td&gt;
   &lt;td&gt;82.3 (2:4-sparse model)
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/accelerating-neural-network-training/fg12.png&quot; alt=&quot;sparsity training diagrams&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;During the sparse training steps, in the backward pass we obtain a dense gradient for the sparse weights. For the gradient descent to be sound, we should also sparsify this gradient before using it in the optimizer to update the weights. Instead of doing that, we use the full dense gradient to update the weights - we found this to work better in practice: this is the STE (&lt;a href=&quot;https://arxiv.org/pdf/1903.05662&quot;&gt;Straight Through Estimator&lt;/a&gt;) strategy. In other words, we update all the parameters at every step, even the ones we don’t use.&lt;/p&gt;

&lt;h2 id=&quot;conclusion-and-future-work&quot;&gt;Conclusion and Future Work&lt;/h2&gt;

&lt;p&gt;In this blog post, we’ve shown how to accelerate neural network training with semi-structured sparsity and explained some of the challenges we faced. We were able to achieve a 6% end to end speedup on DINOv2 training with a small 0.1 pp accuracy drop.&lt;/p&gt;

&lt;p&gt;There are several areas of expansion for this work:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Expansion to new sparsity patterns:&lt;/strong&gt; Researchers have created new sparsity patterns like &lt;a href=&quot;https://arxiv.org/pdf/2310.02065&quot;&gt;V:N:M&lt;/a&gt; sparsity that use the underlying semi-structured sparse kernels to allow for more flexibility. This is especially interesting for applying sparsity to LLMs, as 2:4 sparsity degrades accuracy too much, but we have seen some positive &lt;a href=&quot;https://arxiv.org/pdf/2310.06927&quot;&gt;results&lt;/a&gt; for more general N:M pattern.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Performance optimizations for sparse fine-tuning:&lt;/strong&gt; This post covers sparse training from scratch, but oftentimes we want to fine-tune a foundational model. In this case, a static mask may be sufficient to preserve accuracy which would enable us to make additional performance optimizations.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;More experiments on pruning strategy:&lt;/strong&gt; We calculate the mask at each step of the network, but calculating the mask every n steps may yield better training accuracy. Overall, figuring out the best strategy to use semi-structured sparsity during training is an open area of research.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Compatibility with fp8:&lt;/strong&gt; The hardware also supports fp8 semi-structured sparsity, and this approach should work similarly with fp8 in principle. In practice, we would need to write similar sparsification kernels, and could possibly fuse them with the scaling of the tensors.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Activation Sparsity:&lt;/strong&gt; Efficient sparsification kernels also enable to sparsify the activations during training. Because the sparsification overhead grows linearly with the sparsified matrix size, setups with large activation tensors compared to the weight tensors could benefit more from activation sparsity than weight sparsity. Furthermore, activations are naturally sparse because of the usage of ReLU or GELU activation functions, reducing accuracy degradation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you are interested in these problems, please feel free to open an issue / PR in &lt;a href=&quot;https://github.com/pytorch/ao&quot;&gt;torchao&lt;/a&gt;, a community we’re building for architecture optimization techniques like quantization and sparsity.  Additionally, if you have general interest in sparsity please reach out in &lt;a href=&quot;discord.gg/cudamode&quot;&gt;CUDA-MODE&lt;/a&gt; (#sparsity)&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Jesse Cai, Daniel Haziza, Supriya Rao</name>
        
        
      </author>

      

      

      
        <summary type="html">Over the past year, we’ve added support for semi-structured (2:4) sparsity into PyTorch. With just a few lines of code, we were able to show a 10% end-to-end inference speedup on segment-anything by replacing dense matrix multiplications with sparse matrix multiplications.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">🎉 PyTorch Docathon H1 2024 Wrap-up 🎉</title>
      <link href="https://pytorch.org/blog/pytorch-docathon-h2-2024-wrap-up/" rel="alternate" type="text/html" title="🎉 PyTorch Docathon H1 2024 Wrap-up 🎉" />
      <published>2024-06-20T00:00:00-07:00</published>
      <updated>2024-06-20T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/pytorch-docathon-h2-2024-wrap-up</id>
      <content type="html" xml:base="https://pytorch.org/blog/pytorch-docathon-h2-2024-wrap-up/">&lt;p&gt;We are thrilled to announce the successful completion of the H1 2024 PyTorch Docathon! The event was a resounding success, and we want to extend our heartfelt gratitude to all the participants who made it possible. Dedication, expertise, and tireless efforts of our open-source contributors have once again helped us to improve PyTorch documentation.&lt;/p&gt;

&lt;p&gt;This Docathon ran from June 4 through June 20 with more than 176 registrants. The energy and enthusiasm were palpable, and entrants were judged on the difficulty of submissions that resulted in over 50 merged pull requests.&lt;/p&gt;

&lt;p&gt;We want to give a special shout-out to our top contributors, who went above and beyond during this event. Your dedication and expertise have been invaluable in enhancing the PyTorch documentation and empowering developers worldwide.&lt;/p&gt;

&lt;h2 id=&quot;meet-the-top-contributors&quot;&gt;Meet the top contributors&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;First place: &lt;a href=&quot;https://github.com/ahoblitz&quot;&gt;ahoblitz&lt;/a&gt;, &lt;a href=&quot;https://github.com/afrittoli&quot;&gt;afrittoli&lt;/a&gt;, &lt;a href=&quot;https://github.com/kiszk&quot;&gt;kiszk&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Second place: &lt;a href=&quot;https://github.com/loganthomas&quot;&gt;loganthomas&lt;/a&gt;, &lt;a href=&quot;https://github.com/ignaciobartol&quot;&gt;ignaciobartol&lt;/a&gt;, &lt;a href=&quot;https://github.com/arunppsg&quot;&gt;arunppsg&lt;/a&gt;, &lt;a href=&quot;https://github.com/alperenunlu&quot;&gt;alperenunlu&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Third place: &lt;a href=&quot;https://github.com/anandptl84&quot;&gt;anandptl84&lt;/a&gt;, &lt;a href=&quot;https://github.com/GdoongMathew&quot;&gt;GdoongMathew&lt;/a&gt;, &lt;a href=&quot;https://github.com/ZailiWang&quot;&gt;ZailiWang&lt;/a&gt;, &lt;a href=&quot;https://github.com/ZhaoqiongZ&quot;&gt;ZhaoqiongZ&lt;/a&gt;, &lt;a href=&quot;https://github.com/jingxu10&quot;&gt;jingxu10&lt;/a&gt;, &lt;a href=&quot;https://github.com/sitamgithub-MSIT&quot;&gt;sitamgithub-MSIT&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Honorable mentions for contributing to PyTorch XLA and torchfix libraries: &lt;a href=&quot;https://github.com/arunppsg&quot;&gt;arunppsg&lt;/a&gt; and &lt;a href=&quot;https://github.com/sitamgithub-MSIT&quot;&gt;sitamgithub-MSIT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the full list of participants, see &lt;a href=&quot;https://github.com/pytorch/tutorials/blob/main/docathon-leaderboard.md&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As we bring this Docathon to a close, we encourage each and every one of you to stay inspired and keep contributing to PyTorch documentation and code, and pushing the boundaries of what’s possible with PyTorch. Your collective efforts are shaping the landscape of deep learning and fostering innovation in the PyTorch community.&lt;/p&gt;

&lt;p&gt;Thank you again for your participation and support. We look forward to seeing what you will achieve next!&lt;/p&gt;

&lt;p&gt;Team PyTorch&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Facebook</name>
        
        
      </author>

      

      

      
        <summary type="html">We are thrilled to announce the successful completion of the H1 2024 PyTorch Docathon! The event was a resounding success, and we want to extend our heartfelt gratitude to all the participants who made it possible. Dedication, expertise, and tireless efforts of our open-source contributors have once again helped us to improve PyTorch documentation.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Reducing Model Checkpointing Times by Over 10x with PyTorch Distributed Asynchronous Checkpointing</title>
      <link href="https://pytorch.org/blog/reducing-checkpointing-times/" rel="alternate" type="text/html" title="Reducing Model Checkpointing Times by Over 10x with PyTorch Distributed Asynchronous Checkpointing" />
      <published>2024-06-12T00:00:00-07:00</published>
      <updated>2024-06-12T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/reducing-checkpointing-times</id>
      <content type="html" xml:base="https://pytorch.org/blog/reducing-checkpointing-times/">&lt;p&gt;&lt;strong&gt;Summary:&lt;/strong&gt;   With PyTorch distributed’s new asynchronous checkpointing feature, developed with feedback from IBM, we show how IBM Research Team is able to implement and reduce effective checkpointing time by a factor of 10-20x.  Example: 7B model ‘down time’ for a checkpoint goes from an average of 148.8 seconds to 6.3 seconds, or 23.62x faster.&lt;/p&gt;

&lt;p&gt;This directly translates into either more net training progress for every given 24 hour period while continuing to robustly checkpoint or more frequent checkpoints to shorten recovery window/time.&lt;/p&gt;

&lt;p&gt;In this note, we showcase the usage code and architecture that makes asynchronous checkpointing possible, along with timing results verified by IBM’s Research team.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/reducing-checkpointing-times/fg1.png&quot; alt=&quot;Async Checkpointing vs Standard Checkpointing&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Model checkpointing is a vital part of large model training, but checkpointing is an expensive process as each checkpoint process involves blocking training progress in order to save out the latest model weights.  However, not checkpointing or reducing checkpointing frequency can result in a significant loss in training progress. For example, failures such as a deadlock, straggler, and gpu errors require the training process to be restarted.  In order to restart from a failure, all (training) workers must stop their training process and be restarted from the last saved checkpoint.&lt;/p&gt;

&lt;p&gt;Thus, the inherent tension between robustness to failures vs training progress plays out as a tradeoff, but now with asynchronous checkpointing, PyTorch Distributed is able to significantly reduce this tension and enable frequent checkpoint with minimal impact to the overall training time.&lt;/p&gt;

&lt;p&gt;For background, it was almost exactly &lt;a href=&quot;https://pytorch.org/blog/performant-distributed-checkpointing/&quot;&gt;a year ago&lt;/a&gt; that we showcased how distributed checkpointing had massively sped up checkpointing times from the original torch.save() functionality.  As IBM Research had noted, torch.save could take up to 30 minutes to checkpoint a single 11B model (PyTorch 1.13).&lt;/p&gt;

&lt;p&gt;With advancements in distributed checkpointing, checkpoints could be done in under 4 minutes for up to 30B model sizes.&lt;/p&gt;

&lt;p&gt;With asynchronous checkpointing, the training time lost due to checkpointing now moves to under 30 seconds, and often as short as 6 seconds.&lt;/p&gt;

&lt;p&gt;To be clear, asynchronous checkpointing does not compress the actual serialization checkpointing time as the previous update showcased.  Rather it moves the final checkpointing process off the critical path (to cpu threads) to allow GPU training to continue while finalizing the checkpoint under separate threads.&lt;/p&gt;

&lt;p&gt;However, to the user, the effect is nearly the same in that down time for training due to checkpointing is substantially reduced, in many cases by 10x or even 20x.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/reducing-checkpointing-times/fg2.png&quot; alt=&quot;Async Dist Checkpointing&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As the above speedup chart shows, asynchronous checkpointing produces a 10x to 23x further improvement over the previous large improvements from a year ago.&lt;/p&gt;

&lt;h2 id=&quot;how-does-asynchronous-checkpointing-work&quot;&gt;How does Asynchronous Checkpointing work?&lt;/h2&gt;

&lt;p&gt;Asynchronous checkpointing modularizes the checkpointing process into two parts rather than one monolithic process.  The first phase copies the data from each gpu/rank from GPU to CPU.  This is the visible downtime to the user and can take from 6 - 14 seconds for 7B-13B model sizes. The second phase asynchronously copies the data from CPU memory to disk to persist the checkpoint.&lt;/p&gt;

&lt;p&gt;Once data is copied to CPU in the first phase, the GPU is free to immediately resume training.  Hence with asynchronous checkpointing the downtime for checkpointing is simply the time needed to copy over the latest model states to CPU.&lt;/p&gt;

&lt;p&gt;At the same time that training resumes, non-blocking CPU threads work with the freshly arrived data in memory to complete the full checkpointing/serialization process to disk (i.e. persistent save).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/reducing-checkpointing-times/fg3.png&quot; alt=&quot;flow diagram&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note that PyTorch’s Distributed Checkpointer relies on collective communication calls for per-rank metadata necessary to optimize saves, as well as a final synchronization which marks checkpointing as complete and makes the action atomic. This can interfere with distributed training (as distributed training also relies upon similar calls to synchronize training across multiple GPUs) if the Checkpointing thread utilizes the same process group used for training.&lt;/p&gt;

&lt;p&gt;Specifically, a race condition between the calls could potentially cause training and asynch checkpointing save threads to wait on collective calls at the same time, resulting in a true collective hang.&lt;/p&gt;

&lt;p&gt;We avoided this scenario by initializing a separate process group for async checkpointing.  This separates the checkpointing collectives into their own logical process group, which thus ensures it will not interfere with collective calls in the main training threads.&lt;/p&gt;

&lt;h2 id=&quot;how-do-i-use-asynchronous-checkpointing-in-my-training&quot;&gt;How do I use Asynchronous Checkpointing in my training?&lt;/h2&gt;

&lt;p&gt;Usage of Asynchronous checkpointing is relatively straightforward.  Using the latest nightly version of PyTorch, you will want to initialize your process group with both nccl and gloo.  Gloo is required for the cpu threads portion.&lt;/p&gt;

&lt;p&gt;From there, create a duplicate process group which the asynchronous checkpointing will utilize.
Then train as usual but at the point when you want to checkpoint, use the asynchronous save api, passing in the states to save, the checkpoint id and the checkpoint process group.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/reducing-checkpointing-times/fg4.png&quot; alt=&quot;Code snippet&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Asynchronous checkpointing is also fully implemented in &lt;a href=&quot;https://github.com/pytorch/torchtitan&quot;&gt;torchtitan&lt;/a&gt;.  Here, it is implemented for use with pre-training your own Llama2 or Lllama3 model.  Using it is as simple as updating the toml config file:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/reducing-checkpointing-times/fg5.png&quot; alt=&quot;Code snippet&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;future-work&quot;&gt;Future work&lt;/h2&gt;

&lt;p&gt;Checkpointing has made huge strides over the past year.  Moving from almost half an hour checkpoints to under 5 minutes with distributed checkpointing and now to under 30 seconds with asynchronous checkpointing.&lt;/p&gt;

&lt;p&gt;The last frontier - zero overhead checkpointing where even the &amp;lt; 30 seconds is eliminated by streaming the updated weights during the backward pass such that checkpoint data is already on cpu at the point asynchronous checkpointing would kick in.&lt;/p&gt;

&lt;p&gt;This would effectively move large model training to where checkpointing has no disruption or downtime enabling both more robustness (as checkpoints could be taken more frequently) and faster training progress due to no downtime for checkpointing.&lt;/p&gt;

&lt;p&gt;Source code link: &lt;a href=&quot;https://github.com/pytorch/pytorch/blob/main/torch/distributed/checkpoint/state_dict_saver.py&quot;&gt;https://github.com/pytorch/pytorch/blob/main/torch/distributed/checkpoint/state_dict_saver.py&lt;/a&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Meta: Lucas Pasqualin, Less Wright, Iris Zhang (PyTorch), Chien-Chin Huang; IBM Research: Swaminathan Sundararaman, Saransh Gupta, Raghu Ganti</name>
        
        
      </author>

      

      

      
        <summary type="html">Summary: With PyTorch distributed’s new asynchronous checkpointing feature, developed with feedback from IBM, we show how IBM Research Team is able to implement and reduce effective checkpointing time by a factor of 10-20x. Example: 7B model ‘down time’ for a checkpoint goes from an average of 148.8 seconds to 6.3 seconds, or 23.62x faster.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">PyTorch Foundation Welcomes New Executive Director</title>
      <link href="https://pytorch.org/blog/new-executive-director/" rel="alternate" type="text/html" title="PyTorch Foundation Welcomes New Executive Director" />
      <published>2024-06-11T00:00:00-07:00</published>
      <updated>2024-06-11T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/new-executive-director</id>
      <content type="html" xml:base="https://pytorch.org/blog/new-executive-director/">&lt;p&gt;&lt;img src=&quot;/assets/images/matt-white.jpg&quot; alt=&quot;Matt White&quot; style=&quot;max-width:220px;float:right;margin-left: 20px;&quot; /&gt;
The PyTorch Foundation is excited to welcome Matt White, our new executive director. The PyTorch Foundation formed in 2022 with the goal to drive adoption of AI tooling by fostering and sustaining an ecosystem of open source, vendor-neutral projects with PyTorch. Over the past 2 years, we’ve seen excellent growth across the project – with both contributor and member growth.&lt;/p&gt;

&lt;p&gt;“I am honored to be a part of the PyTorch Foundation, working with such a passionate and skilled community,” said Matt White. “I am looking forward to working with our contributors and members to advance the PyTorch ecosystem through research, cutting edge technologies and open source best practices.”&lt;/p&gt;

&lt;p&gt;Matt is a career technologist, researcher and innovator and has over 25 years of experience in AI, data, autonomous systems and simulations. He is the Co-founder and Chair of the Open Metaverse Foundation, a part of the Linux Foundation. Previously, Matt was the Director of the Generative AI Commons at the Linux Foundation, leading the advancement of open science and open-source artificial intelligence projects. He is also the GM of AI at the Linux Foundation.&lt;/p&gt;

&lt;h2 id=&quot;learn-more-about-the-pytorch-foundation&quot;&gt;Learn more about the PyTorch Foundation:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Join as a &lt;a href=&quot;https://pytorch.org/join&quot;&gt;member&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Read our latest &lt;a href=&quot;https://pytorch.org/blog/&quot;&gt;announcements&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Access technical resources on &lt;a href=&quot;https://github.com/pytorch/pytorch&quot;&gt;GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Facebook</name>
        
        
      </author>

      

      

      
        <summary type="html">The PyTorch Foundation is excited to welcome Matt White, our new executive director. The PyTorch Foundation formed in 2022 with the goal to drive adoption of AI tooling by fostering and sustaining an ecosystem of open source, vendor-neutral projects with PyTorch. Over the past 2 years, we’ve seen excellent growth across the project – with both contributor and member growth.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">INT4 Decoding GQA CUDA Optimizations for LLM Inference</title>
      <link href="https://pytorch.org/blog/int4-decoding/" rel="alternate" type="text/html" title="INT4 Decoding GQA CUDA Optimizations for LLM Inference" />
      <published>2024-06-06T00:00:00-07:00</published>
      <updated>2024-06-06T00:00:00-07:00</updated>
      <id>https://pytorch.org/blog/int4-decoding</id>
      <content type="html" xml:base="https://pytorch.org/blog/int4-decoding/">&lt;h4 id=&quot;an-efficient-decoding-grouped-query-attention-with-low-precision-kv-cache&quot;&gt;An efficient decoding Grouped-Query Attention with low-precision KV cache&lt;/h4&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Generative AI has taken the world by storm with its ability to generate content like humans.  Many of these generative AI tools are powered by large language models (LLMs), like Meta &lt;a href=&quot;https://llama.meta.com/llama3/&quot;&gt;Llama&lt;/a&gt; models and OpenAI’s &lt;a href=&quot;https://openai.com/gpt-4&quot;&gt;ChatGPT&lt;/a&gt;.  One of the main challenges of LLMs is supporting large “context lengths” (also known as “sequence lengths”).  The context length refers to the number of tokens that the model uses to understand the input context and generate responses.  Longer context lengths generally translate into higher precision and quality in the responses.  However, long context lengths are compute and memory intensive.  This is mainly due to the following reasons:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The computational complexity of attention layers increases proportionally with the context length (the growth rate depends on the attention algorithm).  As a result, when using long context lengths, the attention layers can become a bottleneck, particularly during the prefill phase where attentions are compute bound.&lt;/li&gt;
  &lt;li&gt;The KV cache size grows linearly with the context length, thus, putting higher pressure on the memory requirement and consequently slowing down the already memory-bound attention decoding.  Moreover, since the memory capacity is limited, the batch size reduces when the KV cache gets bigger, which generally results in a drop in throughput.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The computational complexity growth is difficult to solve compared to the other problem mentioned above.  One way to address the KV cache size growth problem is to use low precision KV cache.  From our experiments, group-wise INT4 quantization provides comparable results in terms of accuracy compared to BF16 KV cache during the decode phase in Meta Llama 2 inference.  However, we did not observe any latency improvement, despite reading 4x lesser data in attention decoding layers.  This means that the INT4 attention is 4x less efficient at utilizing precious HBM bandwidth than BF16 attention.&lt;/p&gt;

&lt;p&gt;In this note, we discuss the CUDA optimizations that we applied to INT4 GQA (grouped-query attention – the attention layer that we use in the LLM inference phase) to improve its performance by up to &lt;strong&gt;1.8x on the NVIDIA A100 GPU&lt;/strong&gt; and &lt;strong&gt;1.9x on the NVIDIA H100 GPU&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;strong&gt;optimized CUDA INT4 GQA&lt;/strong&gt; outperformed &lt;a href=&quot;https://pytorch.org/blog/flash-decoding/&quot;&gt;INT4 Flash-Decoding GQA&lt;/a&gt; (the best performing INT4 GQA that we used in the experiment mentioned above) by &lt;strong&gt;1.4x-1.7x on A100&lt;/strong&gt; and &lt;strong&gt;1.09x-1.3x on H100.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;The &lt;strong&gt;optimized CUDA INT4 GQA&lt;/strong&gt; performs better than &lt;strong&gt;BF16 Flash-Decoding GQA&lt;/strong&gt; by &lt;strong&gt;1.5x-1.7x on A100 and 1.4x-1.7x on H100.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;

&lt;h3 id=&quot;gqa-for-llm-inference&quot;&gt;GQA for LLM Inference&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/2305.13245&quot;&gt;Grouped-Query Attention (GQA)&lt;/a&gt; is a variant of multi-head attention (MHA) where each KV cache head is shared across a group of query heads.  Our LLM inference adopts GQA as an attention layer in both the prefill and decode phases in order to reduce the capacity requirement for the KV cache.  We use multiple GPUs in inference where the KV cache and query heads are distributed across GPUs.  Each GPU runs an attention layer with a single KV head and a group of Q heads.  Therefore, when viewed from a single GPU perspective, the GQA component can also be described as &lt;a href=&quot;https://arxiv.org/abs/1911.02150&quot;&gt;MQA (Multi-Query Attention)&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The simplified workflow of decoding GQA is illustrated in Figure 1.  GQA takes three main inputs: input query (denoted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q&lt;/code&gt;), K cache (denoted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt;), and V cache (denoted &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt;).  Our current GQA inference uses BF16 for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q&lt;/code&gt; is a 4D BF16 tensor of shape (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;Q&lt;/sub&gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; is a 4D BF16 tensor of shape (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;sub&gt;max&lt;/sub&gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;KV&lt;/sub&gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; is a 4D BF16 tensor of shape (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;sub&gt;max&lt;/sub&gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;KV&lt;/sub&gt;&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;where&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt; is the batch size (the number of input prompts)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;Q&lt;/sub&gt;&lt;/code&gt; is the number of query heads&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;KV&lt;/sub&gt;&lt;/code&gt; is the number of KV heads (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;Q&lt;/sub&gt;&lt;/code&gt; must be divisible by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;KV&lt;/sub&gt;&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;sub&gt;max&lt;/sub&gt;&lt;/code&gt; is the maximum context length&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt; is the head dimension (fixed to 128)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GQA is simply &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bmm(softmax(bmm(Q, K&lt;sup&gt;T&lt;/sup&gt;) / sqrt(D)), V)&lt;/code&gt;.  This yields a single output tensor (denoted as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O&lt;/code&gt;) which is a 4D BF16 tensor that has the same shape as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q&lt;/code&gt;.  Note that matrix multiplications are performed using BF16, however, accumulation and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;softmax&lt;/code&gt; are carried out in FP32.  We call this “BF16 GQA” as the KV cache is BF16.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg1.png&quot; alt=&quot;Figure 1: The simplified workflow of BF16 GQA for LLM inference&quot; style=&quot;width:100%;display:block;max-width:500px;margin-left:auto;margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 1&lt;/strong&gt; The simplified workflow of BF16 GQA for LLM inference&lt;/p&gt;

&lt;h3 id=&quot;int4-gqa&quot;&gt;INT4 GQA&lt;/h3&gt;

&lt;p&gt;To further reduce the size of the KV cache, we explore the possibility of using INT4 for KV cache instead of BF16.  We estimate the potential performance improvement by calculating the computational intensity (CI) of INT4 GQA and comparing it to that of BF16 GQA, as CI represents FLOPS per byte.  We compute the CI for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PV&lt;/code&gt; (as shown in Equation 1) as they take KV cache as an operand.  Note that we disregard the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Q&lt;/code&gt; load as it is negligible compared to the KV cache.  We also ignore any intermediate data loads/stores that are not on global memory.  Thus, the CI only takes into account the computation FLOPS and KV cache loads.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/eq.jpg&quot; alt=&quot;Equation 1&quot; style=&quot;width:100%;display:block;max-width:400px;margin-left:auto;margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Equation (1)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Assuming that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;Q&lt;/sub&gt;&lt;/code&gt; = 8 and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;sub&gt;KV&lt;/sub&gt;&lt;/code&gt; = 1, CI for BF16 KV cache is 8 while CI for INT4 KV cache is 32.  The CIs indicate that both BF16 and INT4 GQAs are memory bound (the peak CIs for BF16 tensor cores for A100 and H100 are &lt;a href=&quot;https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a100/pdf/a100-80gb-datasheet-update-nvidia-us-1521051-r2-web.pdf&quot;&gt;312 TF / 2 TB/s = 141&lt;/a&gt; and &lt;a href=&quot;https://www.nvidia.com/en-us/data-center/h100/&quot;&gt;990 TF / 3.35 TB/s = 269&lt;/a&gt;; note that these TF numbers are without sparsity).  Moreover, with INT4 KV cache, we should expect up to 4x performance improvement compared to BF16 GQA.&lt;/p&gt;

&lt;p&gt;To enable INT4 KV cache support in GQA, we can dequantize the KV cache from INT4 to BF16 before passing it to the BF16 GQA operator.  However, since KV cache is typically large, copying it from/to global memory can be costly.  Moreover, decoding GQA is a memory bound operation (the memory unit is utilized much more heavily than the compute unit).  Figure 2 shows the NCU profile of the &lt;a href=&quot;https://github.com/facebookresearch/xformers/blob/9f6abadabdec17cd4b5c301632a44bf8216a7f35/xformers/csrc/attention/cuda/fmha/autogen/impl/cutlassF_bf16_aligned.cu#L33&quot;&gt;FMHA CUTLASS BF16 GQA kernel in xFormers&lt;/a&gt;, which is one of the state of the art implementations of GQA.  From the figure, it is obvious that memory is a bottleneck.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg2.png&quot; alt=&quot;Figure 2: The NCU profile of the FMHA CUTLASS BF16 kernel in xFormers&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 2&lt;/strong&gt; The NCU profile of the &lt;a href=&quot;https://github.com/facebookresearch/xformers/blob/9f6abadabdec17cd4b5c301632a44bf8216a7f35/xformers/csrc/attention/cuda/fmha/autogen/impl/cutlassF_bf16_aligned.cu#L33&quot;&gt;FMHA CUTLASS BF16 kernel in xFormers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A more efficient alternative is to fuse INT4 dequantization with the GQA operation (shown in Figure 3).  In other words, having GQA read INT4 KV cache directly and perform the INT4 to BF16 conversion within the kernel.  This change can potentially reduce the amount of global memory reads required for the KV cache, which could lead to a decrease in latency.  We call this “INT4 GQA.”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg3.png&quot; alt=&quot;Figure 3: The workflow of fused INT4 GQA&quot; style=&quot;width:100%;display:block;max-width:500px;margin-left:auto;margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 3&lt;/strong&gt; The workflow of fused INT4 GQA&lt;/p&gt;

&lt;p&gt;We list the state of the art implementations of GQA in the table below along with their features in Table 1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 1&lt;/strong&gt; State of the art GQA implementations&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Implementation&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Denote&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Fused INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;a href=&quot;https://pytorch.org/blog/flash-decoding/&quot;&gt;Flash-Decoding&lt;/a&gt; (Triton implementation)
   &lt;/td&gt;
   &lt;td&gt;FD
   &lt;/td&gt;
   &lt;td&gt;Yes
   &lt;/td&gt;
   &lt;td&gt;Yes
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;a href=&quot;https://github.com/Dao-AILab/flash-attention&quot;&gt;Flash Attention (v2.3.3)&lt;/a&gt;
   &lt;/td&gt;
   &lt;td&gt;FA
   &lt;/td&gt;
   &lt;td&gt;Yes
   &lt;/td&gt;
   &lt;td&gt;No
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;CUDA baseline
   &lt;/td&gt;
   &lt;td&gt;CU
   &lt;/td&gt;
   &lt;td&gt;Yes
   &lt;/td&gt;
   &lt;td&gt;Yes
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;All implementations, except for CU, support both split-K and non split-K.  CU only has the split-K implementation.  Only FA has a heuristic in the backend to determine whether to run the split-K or non split-K kernel.  For other implementations, users must explicitly choose which version to run.  In this note, we focus on long context lengths (in our experiments, we use a context length of 8192) and therefore opt for the split-K version wherever possible.&lt;/p&gt;

&lt;p&gt;As the baseline, we measured the performance of the state of the art GQA implementations on NVIDIA A100 and H100 GPUs.  The latency (time in microseconds) and achieved bandwidth (GB/s) are reported in Table 2.  Note that we ran a range of split-Ks (from 2 to 128 splits) and reported the best performance for each implementation.  For all experiments, we use a context length of 8192.  For INT4 GQA, we used row-wise quantization (i.e., num quantized groups = 1).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 2&lt;/strong&gt; Baseline GQA performance&lt;/p&gt;

&lt;p&gt;On A100&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;139
   &lt;/td&gt;
   &lt;td&gt;133
   &lt;/td&gt;
   &lt;td&gt;183
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;245
   &lt;/td&gt;
   &lt;td&gt;229
   &lt;/td&gt;
   &lt;td&gt;335
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;433
   &lt;/td&gt;
   &lt;td&gt;555
   &lt;/td&gt;
   &lt;td&gt;596
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;826
   &lt;/td&gt;
   &lt;td&gt;977
   &lt;/td&gt;
   &lt;td&gt;1127
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1607
   &lt;/td&gt;
   &lt;td&gt;1670
   &lt;/td&gt;
   &lt;td&gt;2194
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Effective Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;965
   &lt;/td&gt;
   &lt;td&gt;1012
   &lt;/td&gt;
   &lt;td&gt;736
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;1097
   &lt;/td&gt;
   &lt;td&gt;1175
   &lt;/td&gt;
   &lt;td&gt;802
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;1240
   &lt;/td&gt;
   &lt;td&gt;968
   &lt;/td&gt;
   &lt;td&gt;901
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;1301
   &lt;/td&gt;
   &lt;td&gt;1100
   &lt;/td&gt;
   &lt;td&gt;954
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1338
   &lt;/td&gt;
   &lt;td&gt;1287
   &lt;/td&gt;
   &lt;td&gt;980
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;On H100&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;91
   &lt;/td&gt;
   &lt;td&gt;90
   &lt;/td&gt;
   &lt;td&gt;114
   &lt;/td&gt;
   &lt;td&gt;70
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;96
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;148
   &lt;/td&gt;
   &lt;td&gt;146
   &lt;/td&gt;
   &lt;td&gt;200
   &lt;/td&gt;
   &lt;td&gt;113
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;162
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;271
   &lt;/td&gt;
   &lt;td&gt;298
   &lt;/td&gt;
   &lt;td&gt;361
   &lt;/td&gt;
   &lt;td&gt;205
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;294
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;515
   &lt;/td&gt;
   &lt;td&gt;499
   &lt;/td&gt;
   &lt;td&gt;658
   &lt;/td&gt;
   &lt;td&gt;389
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;558
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1011
   &lt;/td&gt;
   &lt;td&gt;1260
   &lt;/td&gt;
   &lt;td&gt;756
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;1066
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Effective Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;1481
   &lt;/td&gt;
   &lt;td&gt;1496
   &lt;/td&gt;
   &lt;td&gt;1178
   &lt;/td&gt;
   &lt;td&gt;511
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;371
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;1815
   &lt;/td&gt;
   &lt;td&gt;1840
   &lt;/td&gt;
   &lt;td&gt;1345
   &lt;/td&gt;
   &lt;td&gt;631
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;443
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;1982
   &lt;/td&gt;
   &lt;td&gt;1802
   &lt;/td&gt;
   &lt;td&gt;1487
   &lt;/td&gt;
   &lt;td&gt;699
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;487
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;2087
   &lt;/td&gt;
   &lt;td&gt;2156
   &lt;/td&gt;
   &lt;td&gt;1634
   &lt;/td&gt;
   &lt;td&gt;736
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;513
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;2150
   &lt;/td&gt;
   &lt;td&gt;2127
   &lt;/td&gt;
   &lt;td&gt;1706
   &lt;/td&gt;
   &lt;td&gt;757
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;537
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;First, let’s discuss the BF16 GQA performance: CU ranks last in terms of performance among all implementations.  FD and FA have comparable performance.  When the batch size is less than or equal to 64, FA utilizes the split-K kernel and performs slightly better than FD.  However, when the batch size is greater than 64, FD performs better.&lt;/p&gt;

&lt;p&gt;The same trend holds true for INT4 GQAs. However, we did not measure the performance of FA as it does not support INT4 KV cache. FD outperforms CU for all cases.&lt;/p&gt;

&lt;p&gt;When comparing the latencies of FD between BF16 and INT4 GQAs, we find that they are almost identical.  This suggests that &lt;em&gt;INT4 GQA is highly inefficient&lt;/em&gt;, which can be further confirmed by the significantly lower achievable bandwidth for INT4 GQA compared to BF16 GQA.  The same trend is also true when looking at the performance of CU.&lt;/p&gt;

&lt;h3 id=&quot;cuda-with-tensor-cores-int4-gqa-implementation&quot;&gt;CUDA with Tensor Cores INT4 GQA Implementation&lt;/h3&gt;

&lt;p&gt;In this section, we briefly describe our baseline implementation which is CUDA with tensor cores INT4 GQA (CU).  Each thread block processes only one KV head and a group of query heads from one input prompt.  Therefore, each thread block performs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mm(softmax(mm(Q, K&lt;sup&gt;T&lt;/sup&gt;) / sqrt(D)), V)&lt;/code&gt;; notice that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mm&lt;/code&gt; is being performed not &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bmm&lt;/code&gt;.  Moreover, since this is a split-K implementation, tokens in the KV cache are split among different thread blocks.  Note that each thread block contains 4 warps (each warp contains 32 threads for NVIDIA A100 and H100 GPUs).  Work in each thread block is split among warps.  Within each warp, we use the &lt;a href=&quot;https://bruce-lee-ly.medium.com/nvidia-tensor-core-introduction-to-wmma-api-programming-21bcfee4ec45&quot;&gt;WMMA&lt;/a&gt; API to compute matrix multiplication on tensor cores.  Figure 4 demonstrates the work partitioning in CU.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg4.jpg&quot; alt=&quot;Figure 4: CU work partitioning&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 4&lt;/strong&gt; CU work partitioning&lt;/p&gt;

&lt;h2 id=&quot;optimizing-cuda-with-tensor-cores-kernel-of-int4-gqa&quot;&gt;Optimizing CUDA with Tensor Cores Kernel of INT4 GQA&lt;/h2&gt;

&lt;p&gt;In this note, we discuss the optimizations that we have applied to the CUDA with tensor cores implementation of INT4 GQA (CU).  The ideal goal is to improve the INT4 GQA performance by 4 times based on the CI analysis in the previous section.  Note that the query size is negligible compared to the KV cache size when the context length is long.&lt;/p&gt;

&lt;p&gt;In our analysis, we used the &lt;a href=&quot;https://docs.nvidia.com/nsight-compute/NsightComputeCli/index.html&quot;&gt;NVIDIA Nsight Compute (NCU)&lt;/a&gt; as the main profiler.  Our general bottleneck elimination approach is to minimize the stall cycles.  We applied 10 optimizations to INT4 GQA, three of which are specific for NVIDIA A100/H100 GPUs.  These optimizations are well known CUDA optimization techniques which can be generalized to many applications.&lt;/p&gt;

&lt;p&gt;It is worth noting that the reason that we choose to optimize the CUDA implementation rather than the Flash-Decoding implementation (FD) (which is Triton based) is because with CUDA, we have a better control of how the low-level instructions are being generated.  Many optimization techniques that we apply such as, operating on tensor core fragments directly (Optimizations 7-9), cannot be done through Triton since it does not expose low-level details to developers.  However, these optimizations can be integrated into the compiler-based solution to make the optimizations available to broader operators, which is indeed a part of our future plan.&lt;/p&gt;

&lt;h3 id=&quot;optimization-1-unroll-k-loads&quot;&gt;Optimization 1: Unroll &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; Loads&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The NCU profile shows that during &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; loading, there are only 2 global loads followed by &lt;em&gt;memory stalls&lt;/em&gt; at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dequantize_permuted_int4&lt;/code&gt;.  The memory stalls are the long scoreboard stalls which indicates the waits for global memory access.  This suggests that the kernel does not issue sufficient memory loads&lt;/p&gt;

&lt;p&gt;to hide the global load latency.  The kernel issues data loading, and then waits to consume the data immediately causing the global load latency to be exposed.  The stalls are shown in Figure 5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg5.png&quot; alt=&quot;Figure 5: K loading before unrolling&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 5&lt;/strong&gt; K loading before unrolling (the numbers that the arrows point to are stall cycles caused by global memory wait)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;In the baseline implementation, we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint32_t&lt;/code&gt; to load 8 INT4 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; values in a single load and we perform 2 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint32_t&lt;/code&gt; loads in each iteration, which is 16 INT4 K values.  To allow for a better global load latency hiding, we issue 8 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint32_t&lt;/code&gt; loads instead of two before consuming the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; values in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dequantize_permuted_int4&lt;/code&gt;.  This allows the compiler to unroll the loads as well as reorder the instructions to hide the global load latency better.  Figure 6 shows the NCU profile of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; loading after unrolling.  Comparing Figure 5 and Figure 6, we effectively reduce the stall cycles by unrolling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; loads.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg6.png&quot; alt=&quot;Figure 6: K loading after unrolling&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 6&lt;/strong&gt; K loading after unrolling (the numbers that the arrows point to are stall cycles caused by global memory wait)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Results:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 3&lt;/strong&gt; Performance of Optimization 1 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 1&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 1&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;134
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;267
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.02&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.07&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;237
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;302
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;0.99&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.09&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;422
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;339
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.02&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.08&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;806
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;355
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.01&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.07&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1550
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;369
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.02&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.07&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-2-improve-p-type-casting-fp32-bf16&quot;&gt;Optimization 2: Improve &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; Type Casting (FP32-&amp;gt;BF16)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since the product of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;softmax(bmm(Q, K&lt;sup&gt;T&lt;/sup&gt;) / sqrt(D))&lt;/code&gt; is FP32 (denoted as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; in Figure 3), the kernel has to convert &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; from FP32 to BF16 before feeding it to the next &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bmm&lt;/code&gt; computation.  The kernel performs the FP32 to BF16 conversion of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; by copying the FP32 data from one location in shared memory to another location in shared memory.  This causes stalls during the shared memory access (shown in Figure 7) which might be caused by (1) the shared memory indirection; and (2) the shared memory bank conflict since each thread accesses an 16-bit element (because of this, two threads can access the same memory bank simultaneously).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg7.png&quot; alt=&quot;Figure 7: P type casting before Optimization 2&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 7&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; type casting before Optimization 2 (the number that the arrow points to is stall cycles caused by shared memory wait)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We use all threads in the thread block to do in-place type conversion.  Each thread operates on two consecutive elements in order to avoid the shared memory bank conflict when storing BF16.  All threads work on the same head (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;h&lt;/code&gt;) at the same time to guarantee correctness of the conversion.  The in-place conversion steps are as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Each thread loads 2 FP32 token elements from the same head from the shared memory into registers&lt;/li&gt;
  &lt;li&gt;Call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__syncthreads()&lt;/code&gt; to make sure that every thread finishes reading the data&lt;/li&gt;
  &lt;li&gt;Each thread converts its data to 2 BF16 token elements and then stores the results to the same shared memory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Some optimizations that we apply to the implementation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Use vector types (especially &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nv_bfloat2&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Unroll data loading/storing, i.e., performing multiple loads before calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__syncthreads()&lt;/code&gt; and performing multiple stores after &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__syncthreads()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After this optimization, long stalls are not observed during &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; type casting as shown in Figure 8.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg8.png&quot; alt=&quot;Figure 8: P type casting after Optimization 2&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 8&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; type casting after Optimization 2 (the numbers that the arrow points to are stall cycles caused by shared memory wait)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Culprits:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Since we unroll data loading/storing by using registers as an intermediate storage, the number of registers per thread increases resulting in reduced occupancy.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Results:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 4&lt;/strong&gt; Performance of Optimization 2 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 2&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 2&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;126
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;285
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.09&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.14&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;221
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;324
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.06&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.16&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;395
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.09&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.15&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;749
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;382
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.09&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.16&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1435
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;399
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.10&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.16&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-3-remove-local-memory-usage-for-max-qkt-computation&quot;&gt;Optimization 3: Remove Local Memory Usage for max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; computation&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;During the softmax computation, the kernel has to compute max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; for each head. It uses a temporary “thread-local” storage for storing per-thread max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; results (one float value for each head).  Depending on the compiler, the thread-local storage can be allocated on registers (on chip) or the local memory (off chip == global memory).  Unfortunately, in the baseline, the thread-local storage resides in the local memory which is much slower than the registers (shown in Figure 9).  We suspect that this is because the compiler cannot determine the indices of thread-local storage at compile time (since the number of heads (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;/code&gt;) in the kernel is a runtime variable).  Accessing local memory as if accessing registers can hurt the performance of the kernel.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg9.png&quot; alt=&quot;Figure 9: Local memory access during max QKT computation&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 9&lt;/strong&gt; Local memory access during max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; computation&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We realize that we do not need &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;H&lt;/code&gt; (number of heads) floats as temporary storage per thread since each thread can compute max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; for only one head instead of all the heads.  Thus, we only need one float per thread, which can be easily stored in a register.  To accumulate the max results among warps, we use shared memory.  This optimization eliminates the local memory usage during max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; computation.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Results:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 5&lt;/strong&gt; Performance of Optimization 3 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 3&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 3&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;119
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;300
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.14&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.20&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;206
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;348
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.14&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.25&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;368
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;389
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.17&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.24&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;696
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;411
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.17&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.24&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1338
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;428
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.18&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.24&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-4-remove-local-memory-usage-for-row-sum&quot;&gt;Optimization 4: Remove local memory usage for row sum&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Similar to&lt;a href=&quot;https://www.internalfb.com/diff/D50183201&quot;&gt; &lt;/a&gt;Optimization 3, the local memory usage problem is also observed during the row sum computation in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;softmax&lt;/code&gt; computation.  Since local memory is off chip, accessing it as if accessing registers can hurt the performance of the kernel.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;We apply the same solution as the max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; computation for the row sum computation.  That is to have each thread compute a row sum of only one head, which requires only one float per thread.  This eliminates the need for local memory.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Results:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 6&lt;/strong&gt; Performance of Optimization 4 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 4&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 4&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;118
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;302
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.15&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.21&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;204
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.15&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.26&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;364
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;393
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.19&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.25&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;688
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;416
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.18&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.26&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1328
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;431
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.19&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.25&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-5-add-prefetch-for-v-load&quot;&gt;Optimization 5: Add prefetch for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; load&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The same issue as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; loading is observed when loading &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt;.  That is, the kernel issues data loading, and then waits to consume the data immediately causing the global load latency to be exposed.  However, when using the unrolling technique mentioned above, the compiler allocates the temporary buffer on local memory instead of registers causing a large slow down.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We adopt the data prefetching technique for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; loading.  We load the next iteration &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; values immediately after the current iteration values are consumed.  This allows the data loading to be overlapped with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PK&lt;/code&gt; computation resulting in better kernel performance.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Results:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 7&lt;/strong&gt; Performance of Optimization 5 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 5&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 5&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;109
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;327
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.25&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.31&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;194
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;370
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.21&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.33&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;414
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.25&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.32&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;649
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;441
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.26&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.33&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1244
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;460
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.27&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.33&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-6-add-group-wise-int4-groups--4-with-vector-load&quot;&gt;Optimization 6: Add Group-Wise INT4 (Groups = 4) with Vector Load&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Prior to this optimization, CU only supported row-wise INT4 quantization.  That is, every column in each row shares the same scales.  The scales of each row are stored in the first 4 bytes of each row as shown in Figure 10.  In the kernel, each thread loads only one row at a time.  Since each row contains 68 bytes (4 bytes for scales and 64 bytes for data), it cannot guarantee that every row aligns with a size of any vector type.  Thus, vector loads cannot be used for loading the KV cache.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg10.jpg&quot; alt=&quot;Figure 10: The layout of each row of INT4 KV cache with row-wise quantization&quot; style=&quot;width:100%;display:block;max-width:500px;margin-left:auto;margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 10&lt;/strong&gt; The layout of each row of INT4 KV cache with row-wise quantization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We have implemented support for group-wise INT4 quantization with num groups = 4.  In this case, columns in each row in the KV cache tensor are divided into 4 equal groups.  Columns within the same group share the same scales for quantization/dequantization.  The data layout for INT4 KV cache is shown in Figure 11.   The scales for all groups are serialized and stored at the beginning of each row.  The INT4 data is also serialized and laid out next to the scales.&lt;/p&gt;

&lt;p&gt;Because the number of bytes in each row now becomes 80 bytes, we can use a vector type, i.e., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint2&lt;/code&gt; in our case, to load data.  (We &lt;strong&gt;do not&lt;/strong&gt; use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uint4&lt;/code&gt; since each thread loads only 16 INT4s at a time due to the tensor core fragment size.)  Vector load is generally better than scalar load since it does not cause extra byte loads.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg11.jpg&quot; alt=&quot;Figure 11: The layout of each row of INT4 KV cache with row-wise quantization&quot; style=&quot;width:100%;display:block;max-width:500px;margin-left:auto;margin-right:auto;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 11&lt;/strong&gt; The layout of each row of INT4 KV cache with row-wise quantization&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Results:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 8&lt;/strong&gt; Performance of Optimization 6 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;111
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;322
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.23&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.29&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;192
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;372
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.22&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.34&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;346
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;414
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.25&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.32&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;642
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;446
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.27&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.35&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1244
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;460
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.27&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.33&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Table 9&lt;/strong&gt; Performance of Optimization 6 for INT4 GQA (group-wise quantization with num groups = 4)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;129
   &lt;/td&gt;
   &lt;td&gt;116
   &lt;/td&gt;
   &lt;td&gt;325
   &lt;/td&gt;
   &lt;td&gt;364
   &lt;/td&gt;
   &lt;td&gt;1.31
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;219
   &lt;/td&gt;
   &lt;td&gt;195
   &lt;/td&gt;
   &lt;td&gt;385
   &lt;/td&gt;
   &lt;td&gt;431
   &lt;/td&gt;
   &lt;td&gt;1.36
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;392
   &lt;/td&gt;
   &lt;td&gt;347
   &lt;/td&gt;
   &lt;td&gt;429
   &lt;/td&gt;
   &lt;td&gt;484
   &lt;/td&gt;
   &lt;td&gt;1.39
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;719
   &lt;/td&gt;
   &lt;td&gt;638
   &lt;/td&gt;
   &lt;td&gt;468
   &lt;/td&gt;
   &lt;td&gt;527
   &lt;/td&gt;
   &lt;td&gt;1.41
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1375
   &lt;/td&gt;
   &lt;td&gt;1225
   &lt;/td&gt;
   &lt;td&gt;489
   &lt;/td&gt;
   &lt;td&gt;550
   &lt;/td&gt;
   &lt;td&gt;1.43
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-7-compute-max-qkt-from-wmma-fragment-directly-a100h100-specific&quot;&gt;Optimization 7: Compute max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; From WMMA Fragment Directly (A100/H100 specific)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We observe large stalls due to shared memory accessing during the max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; computation (showing as large short scoreboard stalls) as shown in Figure 12.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg12.png&quot; alt=&quot;Figure 12: Stalls due to shared memory access during max QKT computation&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 12&lt;/strong&gt; Stalls due to shared memory access during max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; computation (the number that the arrow points to is stall cycles caused by shared memory wait)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We bypass shared memory when computing max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; by computing it from the WMMA fragment (i.e., the tensor core fragment) directly.  The layout of the WMMA fragment is specific to the GPU architecture.  In this optimization, we only enabled this optimization for the NVIDIA A100/H100 GPUs. Other GPUs will still use shared memory for the max &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; computation. By bypassing shared memory, we effectively eliminate the stalls caused by shared memory access.  The tensor core layout of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt; fragment which is used for storing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; results is shown in Figure 13.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg13.jpg&quot; alt=&quot;Figure 13: C fragment (QKT storage) tensor core layout on A100/H100&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 13&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt; fragment (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; storage) tensor core layout on A100/H100&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 10&lt;/strong&gt; Performance of Optimization 7 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 7&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 7&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;107
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;333
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.27&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.33&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;183
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;391
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.28&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.40&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;333
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;430
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.30&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.37&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;620
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;461
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.31&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.40&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1206
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;475
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.31&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.38&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Table 11&lt;/strong&gt; Performance of Optimization 7 for INT4 GQA (group-wise quantization with num groups = 4)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CUDA_WMMA Opt 6&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 7&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 7&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;129
   &lt;/td&gt;
   &lt;td&gt;116
   &lt;/td&gt;
   &lt;td&gt;111
   &lt;/td&gt;
   &lt;td&gt;325
   &lt;/td&gt;
   &lt;td&gt;364
   &lt;/td&gt;
   &lt;td&gt;380
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.17&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.04&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;219
   &lt;/td&gt;
   &lt;td&gt;195
   &lt;/td&gt;
   &lt;td&gt;187
   &lt;/td&gt;
   &lt;td&gt;385
   &lt;/td&gt;
   &lt;td&gt;431
   &lt;/td&gt;
   &lt;td&gt;449
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.17&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.04&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;392
   &lt;/td&gt;
   &lt;td&gt;347
   &lt;/td&gt;
   &lt;td&gt;333
   &lt;/td&gt;
   &lt;td&gt;429
   &lt;/td&gt;
   &lt;td&gt;484
   &lt;/td&gt;
   &lt;td&gt;506
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.18&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.04&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;719
   &lt;/td&gt;
   &lt;td&gt;638
   &lt;/td&gt;
   &lt;td&gt;615
   &lt;/td&gt;
   &lt;td&gt;468
   &lt;/td&gt;
   &lt;td&gt;527
   &lt;/td&gt;
   &lt;td&gt;547
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.17&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.04&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1375
   &lt;/td&gt;
   &lt;td&gt;1225
   &lt;/td&gt;
   &lt;td&gt;1184
   &lt;/td&gt;
   &lt;td&gt;489
   &lt;/td&gt;
   &lt;td&gt;550
   &lt;/td&gt;
   &lt;td&gt;569
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.16&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.03&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-8-write-fp32-bf16-results-to-p-fragment-directly-a100h100-specific&quot;&gt;Optimization 8: Write FP32-&amp;gt;BF16 Results to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; Fragment Directly (A100/H100 specific)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;During the FP32-BF16 conversion for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; fragment, the kernel loads the FP32 data from shared memory, does the conversion and then stores the BF16 data back to shared memory.  Moreover, the conversion requires many thread block synchronizations (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__syncthreads()&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Due to the data partitioning design of the kernel, each warp performs only one pass through the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; fragment.  Thus, we do not have to write the conversion results back to the shared memory for future usage.  To avoid writing the BF16 data to the shared memory and thread block synchronizations, we have each warp load the FP32 data of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; WMMA fragment from the shared memory, do the conversion and then write the BF16 data directly to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; fragment.&lt;/p&gt;

&lt;p&gt;Note that this optimization is applied to only the NVIDIA A100 and H100 GPUs because the WMMA fragment layout is architecture dependent.  For non-A100/H100 GPUs, the kernel will fallback to the original path.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; fragment tensor core layout is shown in Figure 14.  Note that this layout is specific to the NVIDIA A100/H100 GPU.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg14.jpg&quot; alt=&quot;Figure 14: P fragment tensor core layout on A100/H100&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 14&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; fragment tensor core layout on A100/H100&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 12&lt;/strong&gt; Performance of Optimization 8 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 8&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 8&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;101
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;353
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.35&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.41&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;174
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;410
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.34&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.47&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;317
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;451
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.36&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.43&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;590
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;485
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.38&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.47&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1143
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;501
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.38&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.45&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Table 13&lt;/strong&gt; Performance of Optimization 8 for INT4 GQA (group-wise quantization with num groups = 4)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CUDA_WMMA Opt 6&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 8&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 8&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;129
   &lt;/td&gt;
   &lt;td&gt;116
   &lt;/td&gt;
   &lt;td&gt;106
   &lt;/td&gt;
   &lt;td&gt;325
   &lt;/td&gt;
   &lt;td&gt;364
   &lt;/td&gt;
   &lt;td&gt;396
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.22&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.09&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;219
   &lt;/td&gt;
   &lt;td&gt;195
   &lt;/td&gt;
   &lt;td&gt;180
   &lt;/td&gt;
   &lt;td&gt;385
   &lt;/td&gt;
   &lt;td&gt;431
   &lt;/td&gt;
   &lt;td&gt;467
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.21&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.08&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;392
   &lt;/td&gt;
   &lt;td&gt;347
   &lt;/td&gt;
   &lt;td&gt;319
   &lt;/td&gt;
   &lt;td&gt;429
   &lt;/td&gt;
   &lt;td&gt;484
   &lt;/td&gt;
   &lt;td&gt;528
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.23&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.09&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;719
   &lt;/td&gt;
   &lt;td&gt;638
   &lt;/td&gt;
   &lt;td&gt;596
   &lt;/td&gt;
   &lt;td&gt;468
   &lt;/td&gt;
   &lt;td&gt;527
   &lt;/td&gt;
   &lt;td&gt;565
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.21&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.07&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1375
   &lt;/td&gt;
   &lt;td&gt;1225
   &lt;/td&gt;
   &lt;td&gt;1138
   &lt;/td&gt;
   &lt;td&gt;489
   &lt;/td&gt;
   &lt;td&gt;550
   &lt;/td&gt;
   &lt;td&gt;591
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.21&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.08&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-9-swizzle-p-shared-memory-layouts-a100h100-specific&quot;&gt;Optimization 9: Swizzle P Shared Memory Layouts (A100/H100 specific)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We observe large shared memory bank conflicts during &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; loading.  The amount of bank conflict depends on the memory access stride.  For instance, for split-Ks = 32 and max seq length = 8192, we observed that only 4 out of 32 banks are being accessed in parallel (memory access stride = 256).  From Figure 14, when all threads access element 0, threads that have the same &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;threadIdx.x % 4&lt;/code&gt; access the same bank.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg15.jpg&quot; alt=&quot;Figure 15: P fragment in shared memory before swizzling&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 15&lt;/strong&gt; P fragment in shared memory before swizzling&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We shuffle the layout of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; load/store in the shared memory in such a way that avoids bank conflicts.  In other words, we store the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QK&lt;sup&gt;T&lt;/sup&gt;&lt;/code&gt; results (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt; fragment) and load them (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; fragment) using the swizzled layout.  Moreover, instead of using the original memory access stride which is dependent on the number of tokens per thread block, we use the fragment’s column size as the stride which is constant.  Thus, the load and store of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;P&lt;/code&gt; fragment is always contiguous.&lt;/p&gt;

&lt;p&gt;The new layouts for the C and P fragments are shown in Figure 16.  With the new layout, it is guaranteed that 16 banks are being accessed in parallel as shown in Figure 17.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg16.jpg&quot; alt=&quot;Figure 16: The swizzled layouts of C and P fragments&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 16&lt;/strong&gt; The swizzled layouts of C and P fragments&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg17.jpg&quot; alt=&quot;Figure 17: P fragment in shared memory after swizzling&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 17&lt;/strong&gt; P fragment in shared memory after swizzling&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 14&lt;/strong&gt; Performance of Optimization 9 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 9&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 9&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;98
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;365
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.39&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.46&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;167
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;429
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.41&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.54&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;299
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;479
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.45&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.52&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;549
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;521
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.48&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.58&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;1060
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;540
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.49&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.56&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Table 15&lt;/strong&gt; Performance of Optimization 9 for INT4 GQA (group-wise quantization with num groups = 4)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CUDA_WMMA Opt 6&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 9&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 9&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;129
   &lt;/td&gt;
   &lt;td&gt;116
   &lt;/td&gt;
   &lt;td&gt;105
   &lt;/td&gt;
   &lt;td&gt;325
   &lt;/td&gt;
   &lt;td&gt;364
   &lt;/td&gt;
   &lt;td&gt;400
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.23&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.10&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;219
   &lt;/td&gt;
   &lt;td&gt;195
   &lt;/td&gt;
   &lt;td&gt;174
   &lt;/td&gt;
   &lt;td&gt;385
   &lt;/td&gt;
   &lt;td&gt;431
   &lt;/td&gt;
   &lt;td&gt;484
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.26&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.12&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;392
   &lt;/td&gt;
   &lt;td&gt;347
   &lt;/td&gt;
   &lt;td&gt;302
   &lt;/td&gt;
   &lt;td&gt;429
   &lt;/td&gt;
   &lt;td&gt;484
   &lt;/td&gt;
   &lt;td&gt;558
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.30&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.15&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;719
   &lt;/td&gt;
   &lt;td&gt;638
   &lt;/td&gt;
   &lt;td&gt;560
   &lt;/td&gt;
   &lt;td&gt;468
   &lt;/td&gt;
   &lt;td&gt;527
   &lt;/td&gt;
   &lt;td&gt;601
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.28&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.14&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1375
   &lt;/td&gt;
   &lt;td&gt;1225
   &lt;/td&gt;
   &lt;td&gt;1065
   &lt;/td&gt;
   &lt;td&gt;489
   &lt;/td&gt;
   &lt;td&gt;550
   &lt;/td&gt;
   &lt;td&gt;632
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.29&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.15&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;optimization-10-pad-shared-memory-for-int4-dequantization&quot;&gt;Optimization 10: Pad Shared Memory for INT4 Dequantization&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Problem Analysis:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Once the kernel reads the INT4 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; cache from global memory, it performs dequantization and stores the results (BF16) in the shared memory.  Then, the BF16 data is loaded to the WMMA fragment from shared memory (via the WMMA interface).  We observed a large number of bank conflicts for both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; accesses.  For instance, for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; stores, only 4 out of 32 banks are being accessed in parallel.  For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; loads, 16 banks are being accessed in parallel.  The same also occurs for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; stores and loads.  See the figures in the solution section.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Solution:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We pad the shared memory to reduce the bank conflict.  Specifically, we pad each row by 2.  That is, the row stride of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; becomes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F_K&lt;/code&gt; + 2 and the row stride of V becomes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F_N&lt;/code&gt; + 2 (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F_K&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F_N&lt;/code&gt; are the fixed widths of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;V&lt;/code&gt; WMMA fragments, respectively).  With this optimization, we are able to reduce the bank conflict by 1.8x as shown in Figure 18.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg18.png&quot; alt=&quot;Figure 18: Bank conflicts before and after Optimization 10&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 18&lt;/strong&gt; Bank conflicts before and after Optimization 10&lt;/p&gt;

&lt;p&gt;After Optimization 10, for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; stores, 32 banks are being accessed in parallel (shown in Figure 19), while for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;K&lt;/code&gt; loads, 29 banks are accessed in parallel (shown in Figure 20).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg19.jpg&quot; alt=&quot;Figure 19: K fragment store shared memory layout without and with padding&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 19&lt;/strong&gt; K fragment store shared memory layout without and with padding&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg20.jpg&quot; alt=&quot;Figure 20: K fragment load shared memory layout without and with padding&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 20&lt;/strong&gt; K fragment load shared memory layout without and with padding&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 16&lt;/strong&gt; Performance of Optimization 10 for INT4 GQA (row-wise quantization)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CU&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CU baseline&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 10&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Baseline&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 10&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;94
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;380
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.45&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.52&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;151
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;475
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.55&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.71&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;266
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;538
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.63&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.71&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;489
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;586
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.67&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.77&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;930
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;616
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.70&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.79&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Table 17&lt;/strong&gt; Performance of Optimization 10 for INT4 GQA (group-wise quantization with num groups = 4)&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;3&quot;&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;3&quot;&gt;&lt;strong&gt;Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;Speed up&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;2&quot;&gt;&lt;strong&gt;CUDA_WMMA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td rowspan=&quot;2&quot;&gt;&lt;strong&gt;vs CUDA_WMMA Opt 6&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 10&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 6&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;Opt 10&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;129
   &lt;/td&gt;
   &lt;td&gt;116
   &lt;/td&gt;
   &lt;td&gt;99
   &lt;/td&gt;
   &lt;td&gt;325
   &lt;/td&gt;
   &lt;td&gt;364
   &lt;/td&gt;
   &lt;td&gt;425
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.31&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.17&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;219
   &lt;/td&gt;
   &lt;td&gt;195
   &lt;/td&gt;
   &lt;td&gt;161
   &lt;/td&gt;
   &lt;td&gt;385
   &lt;/td&gt;
   &lt;td&gt;431
   &lt;/td&gt;
   &lt;td&gt;523
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.36&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.21&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;392
   &lt;/td&gt;
   &lt;td&gt;347
   &lt;/td&gt;
   &lt;td&gt;282
   &lt;/td&gt;
   &lt;td&gt;429
   &lt;/td&gt;
   &lt;td&gt;484
   &lt;/td&gt;
   &lt;td&gt;598
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.39&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.23&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;719
   &lt;/td&gt;
   &lt;td&gt;638
   &lt;/td&gt;
   &lt;td&gt;509
   &lt;/td&gt;
   &lt;td&gt;468
   &lt;/td&gt;
   &lt;td&gt;527
   &lt;/td&gt;
   &lt;td&gt;662
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.41&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.25&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1375
   &lt;/td&gt;
   &lt;td&gt;1225
   &lt;/td&gt;
   &lt;td&gt;965
   &lt;/td&gt;
   &lt;td&gt;489
   &lt;/td&gt;
   &lt;td&gt;550
   &lt;/td&gt;
   &lt;td&gt;698
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.43&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;1.27&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;performance-evaluation&quot;&gt;Performance Evaluation&lt;/h2&gt;

&lt;h3 id=&quot;microbenchmark-results&quot;&gt;Microbenchmark results&lt;/h3&gt;

&lt;p&gt;We also evaluated BF16 GQA performance using our optimized kernel (as shown in Table 19).  CU still performs generally worse than FD and FA for BF16.  This is expected since our optimizations are INT4 focused.&lt;/p&gt;

&lt;p&gt;While INT4 GQA is still not as efficient as BF16 GQA (see the achieved bandwidths), it is important to note that when comparing FD BF16 GQA performance against CU INT4 GQA performance, &lt;strong&gt;we can see that the latency of INT4 is smaller than that of BF16&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Table 19&lt;/strong&gt; Performance of BF16 GQA and INT GQA after CU optimizations&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;On A100&lt;/strong&gt;&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;4&quot;&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;4&quot;&gt;&lt;strong&gt;INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU before&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU after&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU before&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU after&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;139
   &lt;/td&gt;
   &lt;td&gt;133
   &lt;/td&gt;
   &lt;td&gt;183
   &lt;/td&gt;
   &lt;td&gt;163
   &lt;/td&gt;
   &lt;td&gt;137
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;143
   &lt;/td&gt;
   &lt;td&gt;94
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;245
   &lt;/td&gt;
   &lt;td&gt;229
   &lt;/td&gt;
   &lt;td&gt;335
   &lt;/td&gt;
   &lt;td&gt;276
   &lt;/td&gt;
   &lt;td&gt;234
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;257
   &lt;/td&gt;
   &lt;td&gt;151
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;433
   &lt;/td&gt;
   &lt;td&gt;555
   &lt;/td&gt;
   &lt;td&gt;596
   &lt;/td&gt;
   &lt;td&gt;517
   &lt;/td&gt;
   &lt;td&gt;432
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;455
   &lt;/td&gt;
   &lt;td&gt;266
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;826
   &lt;/td&gt;
   &lt;td&gt;977
   &lt;/td&gt;
   &lt;td&gt;1127
   &lt;/td&gt;
   &lt;td&gt;999
   &lt;/td&gt;
   &lt;td&gt;815
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;866
   &lt;/td&gt;
   &lt;td&gt;489
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1607
   &lt;/td&gt;
   &lt;td&gt;1670
   &lt;/td&gt;
   &lt;td&gt;2194
   &lt;/td&gt;
   &lt;td&gt;1879
   &lt;/td&gt;
   &lt;td&gt;1581
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;1659
   &lt;/td&gt;
   &lt;td&gt;930
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Effective Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;4&quot;&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;4&quot;&gt;&lt;strong&gt;INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU before&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU after&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU before&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU after&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;965
   &lt;/td&gt;
   &lt;td&gt;1012
   &lt;/td&gt;
   &lt;td&gt;736
   &lt;/td&gt;
   &lt;td&gt;824
   &lt;/td&gt;
   &lt;td&gt;262
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;250
   &lt;/td&gt;
   &lt;td&gt;380
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;1097
   &lt;/td&gt;
   &lt;td&gt;1175
   &lt;/td&gt;
   &lt;td&gt;802
   &lt;/td&gt;
   &lt;td&gt;972
   &lt;/td&gt;
   &lt;td&gt;305
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;278
   &lt;/td&gt;
   &lt;td&gt;475
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;1240
   &lt;/td&gt;
   &lt;td&gt;968
   &lt;/td&gt;
   &lt;td&gt;901
   &lt;/td&gt;
   &lt;td&gt;1039
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;314
   &lt;/td&gt;
   &lt;td&gt;538
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;1301
   &lt;/td&gt;
   &lt;td&gt;1100
   &lt;/td&gt;
   &lt;td&gt;954
   &lt;/td&gt;
   &lt;td&gt;1075
   &lt;/td&gt;
   &lt;td&gt;351
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;331
   &lt;/td&gt;
   &lt;td&gt;586
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1338
   &lt;/td&gt;
   &lt;td&gt;1287
   &lt;/td&gt;
   &lt;td&gt;980
   &lt;/td&gt;
   &lt;td&gt;1144
   &lt;/td&gt;
   &lt;td&gt;362
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;345
   &lt;/td&gt;
   &lt;td&gt;616
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;On H100&lt;/strong&gt;&lt;/p&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Time (us)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;4&quot;&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;4&quot;&gt;&lt;strong&gt;INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU before&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU after&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU before&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU after&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;91
   &lt;/td&gt;
   &lt;td&gt;90
   &lt;/td&gt;
   &lt;td&gt;114
   &lt;/td&gt;
   &lt;td&gt;100
   &lt;/td&gt;
   &lt;td&gt;70
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;96
   &lt;/td&gt;
   &lt;td&gt;64
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;148
   &lt;/td&gt;
   &lt;td&gt;146
   &lt;/td&gt;
   &lt;td&gt;200
   &lt;/td&gt;
   &lt;td&gt;183
   &lt;/td&gt;
   &lt;td&gt;113
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;162
   &lt;/td&gt;
   &lt;td&gt;101
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;271
   &lt;/td&gt;
   &lt;td&gt;298
   &lt;/td&gt;
   &lt;td&gt;361
   &lt;/td&gt;
   &lt;td&gt;308
   &lt;/td&gt;
   &lt;td&gt;205
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;294
   &lt;/td&gt;
   &lt;td&gt;170
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;515
   &lt;/td&gt;
   &lt;td&gt;499
   &lt;/td&gt;
   &lt;td&gt;658
   &lt;/td&gt;
   &lt;td&gt;556
   &lt;/td&gt;
   &lt;td&gt;389
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;558
   &lt;/td&gt;
   &lt;td&gt;306
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;1000
   &lt;/td&gt;
   &lt;td&gt;1011
   &lt;/td&gt;
   &lt;td&gt;1260
   &lt;/td&gt;
   &lt;td&gt;1066
   &lt;/td&gt;
   &lt;td&gt;756
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;1066
   &lt;/td&gt;
   &lt;td&gt;575
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;table class=&quot;table table-bordered&quot;&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Effective Bandwidth (GB/s)&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;4&quot;&gt;&lt;strong&gt;BF16 GQA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td colspan=&quot;4&quot;&gt;&lt;strong&gt;INT4 GQA&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;strong&gt;Batch size&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU before&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU after&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FD&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;FA&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU before&lt;/strong&gt;
   &lt;/td&gt;
   &lt;td&gt;&lt;strong&gt;CU after&lt;/strong&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;32
   &lt;/td&gt;
   &lt;td&gt;1481
   &lt;/td&gt;
   &lt;td&gt;1496
   &lt;/td&gt;
   &lt;td&gt;1178
   &lt;/td&gt;
   &lt;td&gt;1341
   &lt;/td&gt;
   &lt;td&gt;511
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;371
   &lt;/td&gt;
   &lt;td&gt;560
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;64
   &lt;/td&gt;
   &lt;td&gt;1815
   &lt;/td&gt;
   &lt;td&gt;1840
   &lt;/td&gt;
   &lt;td&gt;1345
   &lt;/td&gt;
   &lt;td&gt;1470
   &lt;/td&gt;
   &lt;td&gt;631
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;443
   &lt;/td&gt;
   &lt;td&gt;710
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;128
   &lt;/td&gt;
   &lt;td&gt;1982
   &lt;/td&gt;
   &lt;td&gt;1802
   &lt;/td&gt;
   &lt;td&gt;1487
   &lt;/td&gt;
   &lt;td&gt;1743
   &lt;/td&gt;
   &lt;td&gt;699
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;487
   &lt;/td&gt;
   &lt;td&gt;844
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;256
   &lt;/td&gt;
   &lt;td&gt;2087
   &lt;/td&gt;
   &lt;td&gt;2156
   &lt;/td&gt;
   &lt;td&gt;1634
   &lt;/td&gt;
   &lt;td&gt;1934
   &lt;/td&gt;
   &lt;td&gt;736
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;513
   &lt;/td&gt;
   &lt;td&gt;935
   &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;512
   &lt;/td&gt;
   &lt;td&gt;2150
   &lt;/td&gt;
   &lt;td&gt;2127
   &lt;/td&gt;
   &lt;td&gt;1706
   &lt;/td&gt;
   &lt;td&gt;2015
   &lt;/td&gt;
   &lt;td&gt;757
   &lt;/td&gt;
   &lt;td&gt;-
   &lt;/td&gt;
   &lt;td&gt;537
   &lt;/td&gt;
   &lt;td&gt;996
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;e2e-results&quot;&gt;E2E results&lt;/h3&gt;

&lt;p&gt;We evaluated our optimized INT4 GQA kernel in Llama 2 70B on 8 H100 GPUs. We ran the model end-to-end, but only reported the decode latency.  We use FP8 FFN (feed forward network) to emphasize the attention performance in the decoding phase.  We vary the batch size from 1 to 256 and the context length from 2,048 (2K) to 16,384 (16K).  The E2E performance results are shown in the figure below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/int4-decoding/fg21.png&quot; alt=&quot;Figure 21: Meta Llama 2 decode latency (ms) comparison&quot; style=&quot;width:100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Figure 21&lt;/strong&gt; Meta Llama 2 decode latency (ms) comparison (BF16 GQA runs out of memory in large batch size configurations)&lt;/p&gt;

&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;

&lt;p&gt;If you are interested, please checkout our code &lt;a href=&quot;https://github.com/pytorch/FBGEMM/tree/main/fbgemm_gpu/experimental/gen_ai&quot;&gt;here&lt;/a&gt;.  If you have any questions, please feel free to open an issue on GitHub, and we will be happy to help.  Your contributions are welcome!&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Sarunya Pumma, Jongsoo Park, Jianyu Huang, Amy Yang, Jaewon Lee, Daniel Haziza, Grigory Sizov, Jeremy Reizenstein, Jeff Johnson, Ying Zhang</name>
        
        
      </author>

      

      

      
        <summary type="html">An efficient decoding Grouped-Query Attention with low-precision KV cache</summary>
      

      
      
    </entry>
  
</feed>


